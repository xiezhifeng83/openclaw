# Moltbot 项目分析与微信插件开发 - 完整输出结果

## 目录

1. [问题 1: 项目如何控制本地电脑](#问题-1-项目如何控制本地电脑)
2. [问题 2: 如何使用微信来通讯](#问题-2-如何使用微信来通讯)
3. [深入分析: Telegram 和 WhatsApp 通道实现](#深入分析-telegram-和-whatsapp-通道实现)
4. [微信插件模板设计](#微信插件模板设计)
5. [完成总结](#完成总结)

---

## 问题 1: 项目如何控制本地电脑

Moltbot 通过以下机制实现本地电脑控制：

### 核心架构

```
通讯渠道 (Telegram/Discord/WhatsApp/Signal等)
           ↓
      Gateway (WebSocket 控制平面)
           ↓
      AI Agent (推理引擎)
           ↓
      工具执行 (Bash/Browser/文件操作等)
```

### 命令执行层

- **基础执行引擎**: `src/process/exec.ts`
  - `runExec()`: 简单的 execFile 包装
  - `runCommandWithTimeout()`: 支持 stdin/stdout 流、超时管理、子进程生成

- **高级 Bash 工具**: `src/agents/bash-tools.exec.ts`
  - 支持 PTY (伪终端) 交互
  - **审批系统**: 敏感命令需要人类批准 (`src/infra/exec-approvals.ts`)
  - **沙箱支持**: Docker/系统隔离
  - **后台执行**: 异步命令跟踪

### 安全机制

- **权限列表**: 已批准的命令缓存
- **审批流程**: 危险操作需要通过 Gateway 获得明确批准
- **执行审批管理器**: `src/gateway/exec-approval-manager.ts`

---

## 问题 2: 如何使用微信来通讯

目前项目**原生不支持微信**。查看支持的通道列表 (`src/channels/registry.ts`):

```typescript
const CHAT_CHANNEL_ORDER = [
  "telegram", "whatsapp", "discord", "googlechat",
  "slack", "signal", "imessage"
];
```

### 实现微信通道的方案

**方案 A: 开发微信插件 (推荐)**

基于项目的插件系统，你需要：

1. **创建插件结构**:
```
moltbot-plugin-wechat/
├── package.json
├── manifest.json
└── src/
    ├── index.ts        # 插件入口
    ├── monitor.ts      # 消息监听
    └── send.ts         # 消息发送
```

2. **实现通道适配器** (参考 `src/channels/plugins/types.adapters.ts`):
```typescript
export type ChannelOutboundAdapter = {
  deliveryMode: "direct" | "gateway" | "hybrid";
  sendText?: (ctx) => Promise<OutboundDeliveryResult>;
  sendMedia?: (ctx) => Promise<OutboundDeliveryResult>;
};
```

3. **选择微信桥接库**:
   - **wechaty**: 最流行的微信机器人框架 (https://wechaty.js.org)
   - **itchat/wxpy**: Python 版本 (需要额外桥接)
   - **wechat-bot**: 轻量级方案

**方案 B: 使用 wechaty 快速集成示例**

```typescript
// src/wechat/monitor.ts
import { WechatyBuilder } from 'wechaty';

export async function startWechatMonitor(gateway: GatewayClient) {
  const bot = WechatyBuilder.build();

  bot.on('message', async (message) => {
    // 转发到 Gateway
    await gateway.send('chat.inbound', {
      channel: 'wechat',
      from: message.talker().name(),
      text: message.text(),
      // ...
    });
  });

  await bot.start();
}
```

```typescript
// src/wechat/send.ts
export const wechatOutbound: ChannelOutboundAdapter = {
  deliveryMode: 'direct',
  async sendText({ to, text }) {
    const contact = await bot.Contact.find({ name: to });
    await contact?.say(text);
    return { ok: true };
  }
};
```

### ⚠️ 微信接入注意事项

1. **风险**: 微信对第三方客户端有严格限制，可能导致账号封禁
2. **协议选择**:
   - **Web 协议**: 需要扫码登录，稳定性一般
   - **iPad/Mac 协议**: 更稳定但需要付费服务 (如 Padlocal)
3. **建议**: 使用小号测试，不要用主要账号

---

## 深入分析: Telegram 和 WhatsApp 通道实现

### 1. 目录结构和文件组织

#### Telegram 通道结构

```
src/telegram/               # 核心 Telegram 实现
├── monitor.ts              # 消息监听器（轮询/Webhook）
├── send.ts                 # 发送器实现
├── bot.ts                  # Grammy 机器人初始化
├── bot-handlers.ts         # 事件处理程序
├── bot-message.ts          # 消息处理流程
├── bot-message-dispatch.ts # 消息分发
├── format.ts               # Markdown to HTML 格式化
├── accounts.ts             # 账户管理（多账户支持）
└── download.ts             # 媒体下载

src/channels/plugins/
├── outbound/telegram.ts     # 出站适配器
├── normalize/telegram.ts    # 目标标准化
├── onboarding/telegram.ts   # 引导流程
└── actions/telegram.ts      # 消息动作（React/Delete/Edit）
```

#### WhatsApp 通道结构

```
src/web/                     # Web 客户端实现（WhatsApp）
├── outbound.ts              # 发送器
├── inbound/monitor.ts       # 监听器
├── session.ts               # Baileys 会话管理
├── media.ts                 # 媒体处理
└── accounts.js              # 账户和认证

src/whatsapp/
└── normalize.ts             # JID 和电话号码标准化

src/channels/plugins/
├── outbound/whatsapp.ts     # 出站适配器
├── normalize/whatsapp.ts    # 目标标准化
├── onboarding/whatsapp.ts   # 引导流程
├── whatsapp-heartbeat.ts    # 心跳检测
└── agent-tools/whatsapp-login.ts  # 登录工具
```

### 2. 监听器（Monitor）实现方式

#### Telegram Monitor 实现

**文件**: `src/telegram/monitor.ts`

```typescript
export async function monitorTelegramProvider(opts: MonitorTelegramOpts = {}) {
  const cfg = opts.config ?? loadConfig();
  const account = resolveTelegramAccount({
    cfg,
    accountId: opts.accountId,
  });
  const token = opts.token?.trim() || account.token;

  // 读取上次的更新偏移量
  let lastUpdateId = await readTelegramUpdateOffset({
    accountId: account.accountId,
  });

  const persistUpdateId = async (updateId: number) => {
    if (lastUpdateId !== null && updateId <= lastUpdateId) return;
    lastUpdateId = updateId;
    try {
      await writeTelegramUpdateOffset({
        accountId: account.accountId,
        updateId,
      });
    } catch (err) {
      (opts.runtime?.error ?? console.error)(
        `telegram: failed to persist update offset: ${String(err)}`
      );
    }
  };

  const bot = createTelegramBot({
    token,
    runtime: opts.runtime,
    proxyFetch,
    config: cfg,
    accountId: account.accountId,
    updateOffset: {
      lastUpdateId,
      onUpdateId: persistUpdateId,
    },
  });

  if (opts.useWebhook) {
    // Webhook 模式
    await startTelegramWebhook({...});
    return;
  }

  // 轮询模式：使用 grammyjs/runner 处理并发更新
  while (!opts.abortSignal?.aborted) {
    const runner = run(bot, createTelegramRunnerOptions(cfg));
    try {
      await runner.task();
      return;
    } catch (err) {
      // 错误处理和重试
      const isConflict = isGetUpdatesConflict(err);
      const isRecoverable = isRecoverableTelegramNetworkError(err, { context: "polling" });
      if (!isConflict && !isRecoverable) {
        throw err;
      }
      // 指数退避重试
      const delayMs = computeBackoff(TELEGRAM_POLL_RESTART_POLICY, restartAttempts);
      await sleepWithAbort(delayMs, opts.abortSignal);
    }
  }
}
```

**关键特性**：
- **更新偏移持久化**: 避免重复处理相同消息
- **Webhook vs 轮询**: 支持两种模式，可配置选择
- **并发处理**: 使用 grammy/runner 处理多个更新
- **错误恢复**: 自动重试可恢复的网络错误

#### WhatsApp Monitor 实现

**文件**: `src/web/inbound/monitor.ts`

```typescript
export async function monitorWebInbox(options: {
  verbose: boolean;
  accountId: string;
  authDir: string;
  onMessage: (msg: WebInboundMessage) => Promise<void>;
  mediaMaxMb?: number;
  sendReadReceipts?: boolean;
  debounceMs?: number;
  shouldDebounce?: (msg: WebInboundMessage) => boolean;
}) {
  // 创建 Baileys WhatsApp 会话
  const sock = await createWaSocket(false, options.verbose, {
    authDir: options.authDir,
  });
  await waitForWaConnection(sock);

  // 消息去重缓存
  const groupMetaCache = new Map<
    string,
    { subject?: string; participants?: string[]; expires: number }
  >();

  // 消息防抖处理（合并快速连续消息）
  const debouncer = createInboundDebouncer<WebInboundMessage>({
    debounceMs: options.debounceMs ?? 0,
    buildKey: (msg) => {
      const senderKey =
        msg.chatType === "group"
          ? (msg.senderJid ?? msg.senderE164 ?? msg.senderName ?? msg.from)
          : msg.from;
      const conversationKey = msg.chatType === "group" ? msg.chatId : msg.from;
      return `${msg.accountId}:${conversationKey}:${senderKey}`;
    },
    shouldDebounce: options.shouldDebounce,
    onFlush: async (entries) => {
      // 合并多条消息
      const combinedMessage = mergeMessages(entries);
      await options.onMessage(combinedMessage);
    },
  });

  sock.ev.on("messages.upsert", handleMessagesUpsert);
}
```

**关键特性**：
- **Baileys 集成**: 使用 @whiskeysockets/baileys 连接 WhatsApp Web
- **消息防抖**: 合并快速连续的消息
- **自动已读**: 发送读取回执（可配置）
- **群组元数据缓存**: 缓存群组信息避免重复查询

### 3. 发送器（Send）实现方式

#### Telegram 发送器

**文件**: `src/telegram/send.ts`

- 支持文本、图片、视频、音频、文档、贴纸
- Markdown → HTML 转换
- 线程/回复支持
- 内联按钮
- 自动重试

#### WhatsApp 发送器

**文件**: `src/web/outbound.ts`

- 通过 Gateway 代理发送
- 支持文本、媒体、投票
- 发送"正在输入"指示
- 媒体类型自动识别

### 4. 配置类型定义

#### Telegram 配置

**文件**: `src/config/types.telegram.ts`

```typescript
export type TelegramAccountConfig = {
  name?: string;
  botToken?: string;
  dmPolicy?: DmPolicy;
  allowFrom?: Array<string | number>;
  groupPolicy?: GroupPolicy;
  textChunkLimit?: number;
  webhookUrl?: string;
  actions?: TelegramActionConfig;
  // ... 更多配置
};
```

#### WhatsApp 配置

**文件**: `src/config/types.whatsapp.ts`

```typescript
export type WhatsAppConfig = {
  sendReadReceipts?: boolean;
  dmPolicy?: DmPolicy;
  allowFrom?: string[];
  groupPolicy?: GroupPolicy;
  debounceMs?: number;
  ackReaction?: { emoji?: string; };
  // ... 更多配置
};
```

### 5. 与 Gateway 的集成方式

#### 出站适配器接口

**文件**: `src/channels/plugins/types.adapters.ts`

```typescript
export type ChannelOutboundAdapter = {
  deliveryMode: "direct" | "gateway" | "hybrid";
  chunker?: ((text: string, limit: number) => string[]) | null;
  chunkerMode?: "text" | "markdown";
  textChunkLimit?: number;
  pollMaxOptions?: number;
  resolveTarget?: (params) => { ok: true; to: string } | { ok: false; error: Error };
  sendPayload?: (ctx: ChannelOutboundPayloadContext) => Promise<OutboundDeliveryResult>;
  sendText?: (ctx: ChannelOutboundContext) => Promise<OutboundDeliveryResult>;
  sendMedia?: (ctx: ChannelOutboundContext) => Promise<OutboundDeliveryResult>;
  sendPoll?: (ctx: ChannelPollContext) => Promise<ChannelPollResult>;
};
```

#### Gateway 适配器接口

```typescript
export type ChannelGatewayAdapter<ResolvedAccount = unknown> = {
  startAccount?: (ctx: ChannelGatewayContext<ResolvedAccount>) => Promise<unknown>;
  stopAccount?: (ctx: ChannelGatewayContext<ResolvedAccount>) => Promise<void>;
  loginWithQrStart?: (params) => Promise<ChannelLoginWithQrStartResult>;
  loginWithQrWait?: (params) => Promise<ChannelLoginWithQrWaitResult>;
  logoutAccount?: (ctx) => Promise<ChannelLogoutResult>;
};
```

### 6. 通道对比总结

| 特性 | Telegram | WhatsApp |
|------|----------|---------|
| **监听模式** | 轮询/Webhook | Baileys WebSocket |
| **发送模式** | 直接 API 调用 | Gateway 代理（Web 会话） |
| **多账户** | ✓（配置化） | ✓（配置化） |
| **消息分块** | Markdown → HTML（4000 字符） | 纯文本（4000 字符） |
| **媒体支持** | 图片/视频/音频/文档/贴纸 | 图片/视频/音频/文档/投票 |
| **群组支持** | ✓（包括论坛主题） | ✓ |
| **线程/回复** | ✓（forum topics + reply) | ✓（嵌入式回复） |
| **反应** | ✓（emoji reactions） | ✓（emoji reactions） |
| **操作** | 发送/删除/编辑/反应/贴纸 | 发送/反应/投票 |
| **认证** | Bot Token | QR 码 + Baileys 会话 |
| **配置位置** | `channels.telegram.*` | `channels.whatsapp.*` + `web.*` |

---

## 微信插件模板设计

### 插件结构

```
moltbot-plugin-wechat/
├── package.json          # 包配置（依赖 wechaty）
├── manifest.json         # 插件清单
├── tsconfig.json         # TypeScript 配置
├── README.md             # 使用说明（中文）
└── src/
    ├── index.ts          # 插件入口，注册通道
    ├── channel.ts        # ChannelPlugin 完整实现
    ├── config.ts         # 配置适配器
    ├── types.ts          # 类型定义
    ├── monitor.ts        # 消息监听（Wechaty 集成）
    ├── send.ts           # 消息发送
    ├── outbound.ts       # ChannelOutboundAdapter 实现
    ├── normalize.ts      # 微信 ID 标准化
    └── session.ts        # Wechaty 会话管理
```

### 核心文件内容

#### package.json

```json
{
  "name": "moltbot-plugin-wechat",
  "version": "0.1.0",
  "description": "WeChat channel plugin for Moltbot",
  "type": "module",
  "main": "dist/index.js",
  "dependencies": {
    "wechaty": "^1.20.2"
  },
  "peerDependencies": {
    "moltbot": ">=0.1.0"
  }
}
```

#### manifest.json

```json
{
  "id": "moltbot-plugin-wechat",
  "name": "WeChat Channel",
  "version": "0.1.0",
  "description": "WeChat messaging channel for Moltbot using Wechaty",
  "main": "dist/index.js",
  "moltbot": {
    "minVersion": "0.1.0",
    "channels": ["wechat"]
  }
}
```

#### src/types.ts

```typescript
export type WeChatPuppetType = "wechat" | "padlocal" | "xp";
export type WeChatDmPolicy = "open" | "allowlist" | "pairing" | "disabled";
export type WeChatGroupPolicy = "open" | "allowlist" | "disabled";

export type WeChatAccountConfig = {
  name?: string;
  enabled?: boolean;
  puppet?: WeChatPuppetType;
  puppetToken?: string;
  dmPolicy?: WeChatDmPolicy;
  allowFrom?: string[];
  groupPolicy?: WeChatGroupPolicy;
  textChunkLimit?: number;
};

export type WeChatResolvedAccount = {
  accountId: string;
  config: WeChatAccountConfig;
  puppet: WeChatPuppetType;
  enabled: boolean;
  dmPolicy: WeChatDmPolicy;
  groupPolicy: WeChatGroupPolicy;
  allowFrom: string[];
  textChunkLimit: number;
};

export type WeChatInboundMessage = {
  id: string;
  from: string;
  fromName: string;
  to: string;
  accountId: string;
  body: string;
  chatType: "direct" | "group";
  chatId: string;
  groupName?: string;
  mentionSelf?: boolean;
  timestamp: number;
};
```

#### src/channel.ts (核心通道定义)

```typescript
export const wechatChannelPlugin = {
  id: "wechat" as const,

  meta: {
    name: "WeChat",
    icon: "wechat",
    description: "WeChat messaging platform integration using Wechaty",
  },

  capabilities: {
    text: true,
    media: true,
    reactions: false,
    threads: false,
    polls: false,
  },

  config: {
    listAccountIds: (cfg) => listAccountIds(cfg),
    resolveAccount: (cfg, accountId) => resolveAccount(cfg, accountId),
    isEnabled: (account, cfg) => isAccountEnabled(account, cfg),
    isConfigured: async (account, cfg) => isAccountConfigured(account, cfg),
  },

  outbound: wechatOutbound,

  gateway: {
    startAccount: async (ctx) => { /* 启动监听 */ },
    stopAccount: async (ctx) => { /* 停止监听 */ },
    loginWithQrStart: async (params) => { /* QR 登录 */ },
    logoutAccount: async (ctx) => { /* 登出 */ },
  },
};
```

#### src/monitor.ts (消息监听)

```typescript
export async function monitorWeChat(options: WeChatMonitorOptions): Promise<void> {
  const account = resolveAccount(options.config, options.accountId);
  const bot = await createWeChatBot(account);

  const handleMessage = async (message: Message) => {
    // 检查是否应该处理消息
    const { allowed } = await shouldProcessMessage(message, account, selfId);
    if (!allowed) return;

    // 转换为内部格式
    const inboundMsg = await convertMessage(message, account.accountId);

    // 转发到处理器
    await options.onMessage(inboundMsg);
  };

  await startWeChatBot(bot, account.accountId, {
    onMessage: handleMessage,
    onQrCode: options.onQrCode,
    onLogin: options.onLogin,
  });
}
```

#### src/send.ts (消息发送)

```typescript
export async function sendMessageWeChat(
  to: string,
  text: string,
  options: WeChatSendOptions,
): Promise<WeChatSendResult> {
  const account = resolveAccount(options.config, options.accountId);
  const bot = getWeChatBot(account.accountId);

  // 找到接收者
  const recipient = isWeChatGroup(target)
    ? await findRoom(bot, target)
    : await findContact(bot, target);

  // 分块发送
  const chunks = chunkText(text, account.textChunkLimit);
  for (const chunk of chunks) {
    await recipient.say(chunk);
  }

  return { messageId, to: target };
}
```

#### src/index.ts (插件入口)

```typescript
export default function initPlugin(api) {
  api.logger.info("Initializing WeChat channel plugin...");
  api.registerChannel(wechatChannelPlugin);
  api.logger.info("WeChat channel plugin initialized successfully");
}

export * from "./types.js";
export { wechatChannelPlugin } from "./channel.js";
export { sendMessageWeChat } from "./send.js";
export { monitorWeChat } from "./monitor.js";
```

### 配置示例

```json5
// ~/.clawdbot/config.json5
{
  channels: {
    wechat: {
      enabled: true,
      puppet: "wechat",  // 或 "padlocal"（需要付费 token）
      // puppetToken: "puppet_padlocal_xxx",
      dmPolicy: "pairing",
      allowFrom: ["wxid_xxx", "用户昵称"],
      groupPolicy: "disabled",
      textChunkLimit: 2000,
    }
  }
}
```

### Puppet 选择指南

| Puppet | 协议 | 费用 | 稳定性 | 功能 | 推荐场景 |
|--------|------|------|--------|------|----------|
| `wechat` | Web | 免费 | 低 | 基础 | 测试/个人使用 |
| `padlocal` | iPad | 付费 | 高 | 完整 | 生产环境 |
| `xp` | Windows | 免费 | 中 | 完整 | Windows 服务器 |

---

## 完成总结

### 已创建的文件

#### 1. 技术分析文档

**文件**: `D:\GitHub\moltbot\技术分析.md`

包含：
- 项目整体架构和入口点
- 本地电脑控制机制（命令执行、安全审批系统）
- 通讯层架构（Gateway WebSocket、消息流程）
- 支持的通讯渠道对比
- 插件系统详解
- Telegram/WhatsApp 通道实现详解
- 微信通道开发指南

#### 2. 微信插件模板

**目录**: `D:\GitHub\moltbot\examples\moltbot-plugin-wechat\`

```
moltbot-plugin-wechat/
├── package.json          # 包配置（依赖 wechaty）
├── manifest.json         # 插件清单
├── tsconfig.json         # TypeScript 配置
├── README.md             # 使用说明（中文）
└── src/
    ├── index.ts          # 插件入口，注册通道
    ├── channel.ts        # ChannelPlugin 完整实现
    ├── config.ts         # 配置适配器
    ├── types.ts          # 类型定义
    ├── monitor.ts        # 消息监听（Wechaty 集成）
    ├── send.ts           # 消息发送
    ├── outbound.ts       # ChannelOutboundAdapter 实现
    ├── normalize.ts      # 微信 ID 标准化
    └── session.ts        # Wechaty 会话管理
```

### 关键接口实现

| 接口 | 文件 | 说明 |
|------|------|------|
| `ChannelPlugin` | `channel.ts` | 通道插件主定义 |
| `ChannelConfigAdapter` | `config.ts` | 配置解析和账户管理 |
| `ChannelOutboundAdapter` | `outbound.ts` | 出站消息发送 |
| `ChannelGatewayAdapter` | `channel.ts` | Gateway 集成（监控、登录、登出）|

### 下一步

要使用微信插件，需要：

1. **安装依赖**:
   ```bash
   cd examples/moltbot-plugin-wechat
   npm install
   npm run build
   ```

2. **配置** `~/.clawdbot/config.json5`:
   ```json5
   {
     channels: {
       wechat: {
         enabled: true,
         puppet: "wechat",
         dmPolicy: "pairing",
       }
     }
   }
   ```

3. **启动并扫码登录**
