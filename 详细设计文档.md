# OpenClaw 详细设计文档

> 版本: 2026.2.1 | 文档版本: 1.0 | 编写日期: 2026-02-02

---

## 目录

1. [设计概述](#1-设计概述)
2. [系统架构设计](#2-系统架构设计)
3. [模块详细设计](#3-模块详细设计)
4. [数据库设计](#4-数据库设计)
5. [接口详细设计](#5-接口详细设计)
6. [前端详细设计](#6-前端详细设计)
7. [移动端设计](#7-移动端设计)
8. [安全设计](#8-安全设计)
9. [部署设计](#9-部署设计)
10. [测试设计](#10-测试设计)

---

## 1. 设计概述

### 1.1 设计目标

本文档提供 OpenClaw 项目的完整技术设计，包含足够的细节以支持从零开始复刻整个应用。

### 1.2 设计原则

| 原则 | 描述 |
|------|------|
| **KISS** | 保持简单，避免不必要的复杂性 |
| **YAGNI** | 不实现当前不需要的功能 |
| **DRY** | 避免代码重复，抽象共性 |
| **SOLID** | 遵循面向对象设计原则 |
| **模块化** | 高内聚低耦合的模块设计 |

### 1.3 技术栈选型

#### 1.3.1 后端技术栈

```yaml
运行时:
  Node.js: ">=22.12.0"
  包管理器: pnpm@10.23.0

语言:
  TypeScript: 5.9.3
  模块系统: ES Modules (ESM)

Web框架:
  主框架: Express@5.2.1
  轻量框架: Hono@4.11.7 (可选)

WebSocket:
  库: ws@8.19.0

验证:
  运行时验证: Zod@4.3.6
  Schema验证: @sinclair/typebox + ajv

工具:
  CLI: Commander@14.0.3
  日志: 自定义实现
  配置: JSON5
```

#### 1.3.2 前端技术栈

```yaml
框架:
  UI库: Lit@3.3.2
  构建: Vite@7.3.1
  测试: Vitest@4.0.18

样式:
  方案: 原生CSS + CSS变量
  主题: 深色/浅色双主题

依赖:
  Markdown: marked@17.0.1
  安全: dompurify@3.3.1
  加密: @noble/ed25519@3.0.0
```

#### 1.3.3 移动端技术栈

```yaml
iOS/macOS:
  语言: Swift 5.9+
  UI: SwiftUI
  项目: XCodeGen + SPM

Android:
  语言: Kotlin
  构建: Gradle
  最低SDK: 26
```

---

## 2. 系统架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              OpenClaw 系统架构                               │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                                 表现层                                       │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐ │
│  │  Web UI   │  │    CLI    │  │   macOS   │  │    iOS    │  │  Android  │ │
│  │   (Lit)   │  │(Commander)│  │  (Swift)  │  │  (Swift)  │  │ (Kotlin)  │ │
│  └─────┬─────┘  └─────┬─────┘  └─────┬─────┘  └─────┬─────┘  └─────┬─────┘ │
│        └──────────────┴──────────────┼──────────────┴──────────────┘        │
│                                      │                                      │
│                            WebSocket/HTTP                                   │
└──────────────────────────────────────┼──────────────────────────────────────┘
                                       │
┌──────────────────────────────────────┼──────────────────────────────────────┐
│                                 网关层                                       │
│                                      │                                      │
│  ┌───────────────────────────────────▼───────────────────────────────────┐  │
│  │                         Gateway Server                                 │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │  │
│  │  │ HTTP Server │  │  WS Server  │  │ Broadcaster │  │   Router    │  │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │  │
│  │  │    Auth     │  │  RPC Mgr    │  │   Session   │  │   Config    │  │  │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────┼──────────────────────────────────────┘
                                       │
┌──────────────────────────────────────┼──────────────────────────────────────┐
│                                 业务层                                       │
│        ┌─────────────────────────────┼─────────────────────────────┐        │
│        │                             │                             │        │
│  ┌─────▼─────┐  ┌─────────────┐  ┌───▼───────┐  ┌─────────────┐           │
│  │   Agent   │  │   Channel   │  │  Session  │  │    Cron     │           │
│  │  Engine   │  │   Manager   │  │  Manager  │  │   Service   │           │
│  └─────┬─────┘  └─────┬───────┘  └───────────┘  └─────────────┘           │
│        │              │                                                     │
│  ┌─────▼─────┐  ┌─────▼───────┐  ┌───────────┐  ┌─────────────┐           │
│  │   Tool    │  │   Plugin    │  │  Memory   │  │   Routing   │           │
│  │  System   │  │   System    │  │  System   │  │   Engine    │           │
│  └───────────┘  └─────────────┘  └───────────┘  └─────────────┘           │
└──────────────────────────────────────┼──────────────────────────────────────┘
                                       │
┌──────────────────────────────────────┼──────────────────────────────────────┐
│                                 集成层                                       │
│  ┌───────────────────────────────────┼───────────────────────────────────┐  │
│  │                          渠道适配器                                    │  │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐        │  │
│  │  │WhatsApp │ │Telegram │ │ Discord │ │  Slack  │ │  其他   │        │  │
│  │  │(Baileys)│ │(grammY) │ │         │ │ (Bolt)  │ │ 30+    │        │  │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                          AI模型适配器                                  │  │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐        │  │
│  │  │Anthropic│ │ OpenAI  │ │ Gemini  │ │ Bedrock │ │ Ollama  │        │  │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────┼──────────────────────────────────────┘
                                       │
┌──────────────────────────────────────┼──────────────────────────────────────┐
│                                 存储层                                       │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐                │
│  │  Config   │  │ Sessions  │  │Credentials│  │ Vector DB │                │
│  │  (JSON5)  │  │  (JSONL)  │  │  (JSON)   │  │(sqlite-vec)│               │
│  └───────────┘  └───────────┘  └───────────┘  └───────────┘                │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 目录结构设计

```
openclaw/
├── src/                           # 主源代码
│   ├── index.ts                   # 入口文件
│   │
│   ├── gateway/                   # 网关模块 (~100文件)
│   │   ├── server.ts              # 主服务器
│   │   ├── server-http.ts         # HTTP服务
│   │   ├── server-ws.ts           # WebSocket服务
│   │   ├── server-broadcast.ts    # 事件广播
│   │   ├── server-chat.ts         # 聊天处理
│   │   ├── server-channels.ts     # 渠道管理
│   │   ├── auth.ts                # 认证逻辑
│   │   ├── client.ts              # 客户端抽象
│   │   ├── net.ts                 # 网络工具
│   │   ├── protocol/              # 协议定义
│   │   │   ├── index.ts
│   │   │   └── schema/            # JSON Schema
│   │   │       ├── frames.ts      # 帧定义
│   │   │       ├── agent.ts
│   │   │       ├── channels.ts
│   │   │       ├── config.ts
│   │   │       ├── error-codes.ts
│   │   │       └── ...
│   │   └── server-methods/        # RPC方法
│   │       ├── index.ts
│   │       ├── chat.ts
│   │       ├── agent.ts
│   │       ├── channels.ts
│   │       ├── config.ts
│   │       ├── sessions.ts
│   │       ├── devices.ts
│   │       ├── cron.ts
│   │       ├── logs.ts
│   │       └── ...
│   │
│   ├── agents/                    # Agent模块
│   │   ├── index.ts
│   │   ├── model-manager.ts       # 模型管理
│   │   ├── model-anthropic.ts     # Anthropic适配
│   │   ├── model-openai.ts        # OpenAI适配
│   │   ├── model-gemini.ts        # Gemini适配
│   │   ├── model-ollama.ts        # Ollama适配
│   │   ├── system-prompt.ts       # 系统提示
│   │   ├── pi-embedded-*.ts       # Pi Runtime集成
│   │   ├── bash-tools.ts          # Bash工具
│   │   ├── browser-tools.ts       # 浏览器工具
│   │   ├── file-tools.ts          # 文件工具
│   │   ├── web-tools.ts           # Web工具
│   │   ├── cli-runner/            # CLI运行器
│   │   └── skills/                # 技能系统
│   │       ├── loader.ts
│   │       ├── registry.ts
│   │       └── ...
│   │
│   ├── channels/                  # 渠道模块
│   │   ├── index.ts
│   │   ├── web/                   # Web渠道
│   │   │   └── inbound.ts
│   │   └── plugins/               # 渠道插件框架
│   │
│   ├── cli/                       # CLI模块
│   │   ├── program.ts             # 主程序
│   │   ├── gateway-cli.ts         # gateway命令
│   │   ├── agent-cli.ts           # agent命令
│   │   ├── message-cli.ts         # message命令
│   │   ├── pairing-cli.ts         # pairing命令
│   │   ├── config-cli.ts          # config命令
│   │   ├── doctor-cli.ts          # doctor命令
│   │   ├── onboard-cli.ts         # onboard命令
│   │   └── program/               # 程序辅助
│   │
│   ├── config/                    # 配置模块
│   │   ├── config.ts              # 配置加载
│   │   ├── schema.ts              # 配置Schema
│   │   ├── defaults.ts            # 默认值
│   │   └── sessions/              # 会话配置
│   │       ├── types.ts
│   │       ├── store.ts
│   │       └── utils.ts
│   │
│   ├── sessions/                  # 会话模块
│   │   ├── index.ts
│   │   ├── manager.ts
│   │   ├── storage.ts
│   │   └── transcript.ts
│   │
│   ├── plugins/                   # 插件模块
│   │   ├── loader.ts
│   │   ├── registry.ts
│   │   ├── manifest.ts
│   │   └── sdk/
│   │
│   ├── memory/                    # 记忆模块
│   │   ├── index.ts
│   │   ├── embeddings.ts
│   │   ├── batch-openai.ts
│   │   ├── batch-gemini.ts
│   │   ├── vector-store.ts
│   │   └── hybrid.ts
│   │
│   ├── routing/                   # 路由模块
│   │   ├── index.ts
│   │   ├── resolver.ts
│   │   └── session-key.ts
│   │
│   ├── cron/                      # 定时任务模块
│   │   ├── service.ts
│   │   ├── scheduler.ts
│   │   └── jobs.ts
│   │
│   ├── security/                  # 安全模块
│   │   ├── index.ts
│   │   ├── external-content.ts
│   │   └── exec-approvals.ts
│   │
│   ├── infra/                     # 基础设施
│   │   ├── dotenv.ts
│   │   ├── ports.ts
│   │   ├── binaries.ts
│   │   ├── env.ts
│   │   ├── errors.ts
│   │   ├── heartbeat-runner.ts
│   │   ├── agent-events.ts
│   │   ├── net/
│   │   │   └── ssrf.ts
│   │   └── outbound/
│   │       ├── deliver.ts
│   │       ├── message.ts
│   │       ├── payloads.ts
│   │       └── targets.ts
│   │
│   ├── browser/                   # 浏览器自动化
│   ├── media/                     # 媒体处理
│   ├── tts/                       # 文字转语音
│   ├── tui/                       # 终端UI
│   ├── web/                       # Web服务
│   ├── canvas-host/               # Canvas渲染
│   ├── logging/                   # 日志系统
│   ├── hooks/                     # 钩子系统
│   ├── commands/                  # 命令处理
│   ├── utils/                     # 工具函数
│   └── types/                     # 类型定义
│
├── ui/                            # Web UI
│   ├── package.json
│   ├── vite.config.ts
│   ├── tsconfig.json
│   ├── index.html
│   ├── public/                    # 静态资源
│   └── src/
│       ├── main.ts                # 入口
│       ├── styles.css             # 样式入口
│       ├── styles/                # 样式文件
│       │   ├── base.css
│       │   ├── layout.css
│       │   ├── components.css
│       │   ├── config.css
│       │   ├── chat.css
│       │   └── chat/
│       └── ui/
│           ├── app.ts             # 主组件
│           ├── app-render.ts      # 渲染逻辑
│           ├── app-chat.ts        # 聊天逻辑
│           ├── app-settings.ts    # 设置管理
│           ├── app-gateway.ts     # 网关事件
│           ├── app-lifecycle.ts   # 生命周期
│           ├── app-polling.ts     # 轮询逻辑
│           ├── gateway.ts         # WS客户端
│           ├── storage.ts         # 本地存储
│           ├── navigation.ts      # 路由
│           ├── theme.ts           # 主题
│           ├── device-auth.ts     # 设备认证
│           ├── device-identity.ts # 设备身份
│           ├── controllers/       # API控制器
│           │   ├── chat.ts
│           │   ├── config.ts
│           │   ├── channels.ts
│           │   ├── sessions.ts
│           │   └── ...
│           ├── views/             # 页面视图
│           │   ├── chat.ts
│           │   ├── overview.ts
│           │   ├── channels.ts
│           │   ├── config.ts
│           │   └── ...
│           ├── chat/              # 聊天组件
│           └── components/        # 通用组件
│
├── apps/                          # 移动端应用
│   ├── android/                   # Android
│   │   ├── app/
│   │   │   └── src/main/
│   │   │       ├── kotlin/
│   │   │       └── res/
│   │   ├── build.gradle.kts
│   │   └── gradle/
│   ├── ios/                       # iOS
│   │   ├── Sources/
│   │   ├── Tests/
│   │   └── project.yml
│   ├── macos/                     # macOS
│   │   ├── Sources/
│   │   ├── Package.swift
│   │   └── Tests/
│   └── shared/                    # 共享库
│       └── OpenClawKit/
│
├── extensions/                    # 渠道扩展
│   ├── whatsapp/
│   │   ├── package.json
│   │   └── src/
│   ├── telegram/
│   ├── discord/
│   ├── slack/
│   ├── signal/
│   ├── imessage/
│   ├── line/
│   ├── matrix/
│   ├── msteams/
│   ├── googlechat/
│   └── ... (30+ 渠道)
│
├── packages/                      # 工作区包
│   ├── clawdbot/                  # 兼容shim
│   └── moltbot/                   # 兼容shim
│
├── docs/                          # 文档
│   ├── _config.yml                # Jekyll配置
│   └── ...
│
├── scripts/                       # 构建脚本
│   ├── build.ts
│   ├── copy-hook-metadata.ts
│   └── write-build-info.ts
│
├── patches/                       # npm包补丁
│
├── package.json                   # 主包配置
├── pnpm-workspace.yaml            # 工作区配置
├── pnpm-lock.yaml                 # 锁文件
├── tsconfig.json                  # TS配置
├── Dockerfile                     # Docker配置
├── docker-compose.yml             # Compose配置
├── fly.toml                       # Fly.io配置
├── render.yaml                    # Render配置
└── README.md
```

---

## 3. 模块详细设计

### 3.1 Gateway 网关模块

#### 3.1.1 模块概述

Gateway是系统的核心，负责客户端连接管理、消息路由和RPC方法处理。

#### 3.1.2 类设计

```typescript
// src/gateway/server.ts

export interface GatewayServerOptions {
  config: OpenClawConfig;
  configPath: string;
  storagePath: string;
  workspacePath: string;
}

export class GatewayServer {
  private httpServer: http.Server;
  private wsServer: WebSocketServer;
  private broadcaster: GatewayBroadcaster;
  private clients: Map<string, GatewayClient>;
  private cronService: CronService;
  private channelManager: ChannelManager;

  constructor(options: GatewayServerOptions);

  async start(): Promise<void>;
  async stop(): Promise<void>;

  // 内部方法
  private setupHttpServer(): void;
  private setupWebSocketServer(): void;
  private handleConnection(ws: WebSocket, request: http.IncomingMessage): void;
  private handleRequest(client: GatewayClient, frame: RequestFrame): Promise<void>;
}
```

```typescript
// src/gateway/server-http.ts

export function createHttpRequestHandler(
  server: GatewayServer
): (req: http.IncomingMessage, res: http.ServerResponse) => void;

export function handleHooksRequest(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  server: GatewayServer
): Promise<void>;

export function handleToolsInvokeHttpRequest(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  server: GatewayServer
): Promise<void>;

export function handleControlUiHttpRequest(
  req: http.IncomingMessage,
  res: http.ServerResponse
): Promise<void>;
```

```typescript
// src/gateway/server-ws.ts

export interface GatewayClientState {
  clientId: string;
  deviceId?: string;
  role: ClientRole;
  scopes: string[];
  connectedAt: number;
  lastActivityAt: number;
}

export class GatewayWebSocketHandler {
  constructor(server: GatewayServer);

  handleUpgrade(
    request: http.IncomingMessage,
    socket: net.Socket,
    head: Buffer
  ): void;

  handleConnection(ws: WebSocket, request: http.IncomingMessage): void;

  private handleMessage(client: GatewayClient, data: Buffer): void;
  private handleClose(client: GatewayClient): void;
  private handleError(client: GatewayClient, error: Error): void;
}
```

```typescript
// src/gateway/auth.ts

export interface ResolvedGatewayAuth {
  mode: "token" | "password";
  token?: string;
  password?: string;
  allowTailscale: boolean;
}

export interface AuthResult {
  authenticated: boolean;
  deviceId?: string;
  scopes: string[];
  user?: TailscaleUser;
}

export function resolveGatewayAuth(config: OpenClawConfig): ResolvedGatewayAuth;

export async function authenticateClient(
  auth: ResolvedGatewayAuth,
  request: http.IncomingMessage,
  connectParams: ConnectParams
): Promise<AuthResult>;

export function authorizeGatewayMethod(
  method: string,
  scopes: string[]
): boolean;
```

```typescript
// src/gateway/server-broadcast.ts

export interface BroadcastOptions {
  event: string;
  payload: unknown;
  scopeFilter?: (client: GatewayClient) => boolean;
}

export class GatewayBroadcaster {
  private clients: Set<GatewayClient>;
  private stateVersion: { presence: number; health: number };

  addClient(client: GatewayClient): void;
  removeClient(client: GatewayClient): void;

  broadcast(options: BroadcastOptions): void;
  broadcastToScopes(event: string, payload: unknown, requiredScopes: string[]): void;

  private applyEventScopeGuards(
    client: GatewayClient,
    event: string
  ): boolean;
}
```

#### 3.1.3 RPC方法设计

```typescript
// src/gateway/server-methods/index.ts

export type GatewayRequestHandler = (
  context: RequestContext,
  params: unknown
) => Promise<unknown>;

export interface RequestContext {
  client: GatewayClient;
  server: GatewayServer;
  config: OpenClawConfig;
}

export const methodHandlers: Record<string, GatewayRequestHandler> = {
  // Chat methods
  "chat.send": handleChatSend,
  "chat.history": handleChatHistory,
  "chat.abort": handleChatAbort,
  "chat.inject": handleChatInject,

  // Agent methods
  "agent": handleAgentExec,
  "agents.list": handleAgentsList,

  // Channel methods
  "channels.status": handleChannelsStatus,
  "channels.login": handleChannelsLogin,
  "channels.logout": handleChannelsLogout,

  // Config methods
  "config.get": handleConfigGet,
  "config.set": handleConfigSet,
  "config.apply": handleConfigApply,
  "config.schema": handleConfigSchema,

  // Session methods
  "sessions.list": handleSessionsList,
  "sessions.patch": handleSessionsPatch,
  "sessions.delete": handleSessionsDelete,

  // Device methods
  "devices.list": handleDevicesList,
  "device.pair.request": handleDevicePairRequest,
  "device.pair.approve": handleDevicePairApprove,
  "device.pair.reject": handleDevicePairReject,

  // Other methods
  "send": handleSend,
  "health": handleHealth,
  "logs.tail": handleLogsTail,
  // ...
};
```

```typescript
// src/gateway/server-methods/chat.ts

import { z } from "zod";

const ChatSendParamsSchema = z.object({
  sessionKey: z.string(),
  runId: z.string().uuid(),
  message: z.array(ContentBlockSchema),
  agentId: z.string().optional(),
  thinkingLevel: z.enum(["none", "low", "medium", "high"]).optional(),
});

export async function handleChatSend(
  context: RequestContext,
  params: unknown
): Promise<{ runId: string }> {
  // 1. 验证参数
  const validated = ChatSendParamsSchema.parse(params);

  // 2. 加载会话
  const session = await loadSessionEntry(context.config, validated.sessionKey);

  // 3. 加载Agent配置
  const agent = resolveAgent(context.config, validated.agentId);

  // 4. 准备执行环境
  const transcript = await loadTranscript(session);

  // 5. 执行Agent
  const runner = new AgentRunner({
    agent,
    session,
    transcript,
    message: validated.message,
    runId: validated.runId,
    broadcaster: context.server.broadcaster,
    thinkingLevel: validated.thinkingLevel,
  });

  // 6. 启动异步执行
  runner.start().catch((err) => {
    context.server.broadcaster.broadcast({
      event: "chat",
      payload: { state: "error", runId: validated.runId, error: err.message },
    });
  });

  return { runId: validated.runId };
}
```

#### 3.1.4 协议帧设计

```typescript
// src/gateway/protocol/schema/frames.ts

import { Type, Static } from "@sinclair/typebox";

export const RequestFrameSchema = Type.Object({
  type: Type.Literal("req"),
  id: Type.String({ format: "uuid" }),
  method: Type.String(),
  params: Type.Optional(Type.Unknown()),
});

export const ResponseFrameSchema = Type.Object({
  type: Type.Literal("res"),
  id: Type.String(),
  ok: Type.Boolean(),
  payload: Type.Optional(Type.Unknown()),
  error: Type.Optional(
    Type.Object({
      code: Type.Number(),
      message: Type.String(),
      details: Type.Optional(Type.Unknown()),
    })
  ),
});

export const EventFrameSchema = Type.Object({
  type: Type.Literal("event"),
  event: Type.String(),
  payload: Type.Optional(Type.Unknown()),
  seq: Type.Optional(Type.Number()),
  stateVersion: Type.Optional(
    Type.Object({
      presence: Type.Number(),
      health: Type.Number(),
    })
  ),
});

export const ConnectParamsSchema = Type.Object({
  version: Type.String(),
  clientId: Type.String(),
  role: Type.Union([
    Type.Literal("operator"),
    Type.Literal("node"),
    Type.Literal("channel"),
  ]),
  scopes: Type.Array(Type.String()),
  deviceId: Type.Optional(Type.String()),
  deviceSignature: Type.Optional(Type.String()),
  devicePayload: Type.Optional(Type.String()),
  token: Type.Optional(Type.String()),
});

export type RequestFrame = Static<typeof RequestFrameSchema>;
export type ResponseFrame = Static<typeof ResponseFrameSchema>;
export type EventFrame = Static<typeof EventFrameSchema>;
export type ConnectParams = Static<typeof ConnectParamsSchema>;
```

---

### 3.2 Agent 代理模块

#### 3.2.1 模块概述

Agent模块负责AI处理逻辑，包括模型管理、提示词构建、工具执行等。

#### 3.2.2 类设计

```typescript
// src/agents/model-manager.ts

export interface ModelConfig {
  provider: "anthropic" | "openai" | "gemini" | "bedrock" | "ollama";
  model: string;
  apiKey?: string;
  baseUrl?: string;
  maxTokens?: number;
  temperature?: number;
}

export interface ModelProvider {
  name: string;
  createCompletion(options: CompletionOptions): AsyncIterableIterator<Block>;
  countTokens(messages: Message[]): Promise<number>;
  isAvailable(): Promise<boolean>;
}

export class ModelManager {
  private providers: Map<string, ModelProvider>;
  private config: ModelConfig[];

  constructor(config: ModelConfig[]);

  async selectModel(preferredModel?: string): Promise<ModelProvider>;

  async createCompletion(
    options: CompletionOptions
  ): AsyncIterableIterator<Block>;

  private async tryWithFallback(
    fn: () => Promise<AsyncIterableIterator<Block>>
  ): AsyncIterableIterator<Block>;
}
```

```typescript
// src/agents/model-anthropic.ts

import Anthropic from "@anthropic-ai/sdk";

export class AnthropicProvider implements ModelProvider {
  name = "anthropic";
  private client: Anthropic;
  private model: string;

  constructor(config: ModelConfig);

  async *createCompletion(
    options: CompletionOptions
  ): AsyncIterableIterator<Block> {
    const stream = await this.client.messages.stream({
      model: this.model,
      max_tokens: options.maxTokens,
      system: options.systemPrompt,
      messages: this.convertMessages(options.messages),
      tools: this.convertTools(options.tools),
    });

    for await (const event of stream) {
      if (event.type === "content_block_delta") {
        yield this.convertDelta(event);
      }
    }
  }

  async countTokens(messages: Message[]): Promise<number>;
  async isAvailable(): Promise<boolean>;
}
```

```typescript
// src/agents/system-prompt.ts

export interface SystemPromptOptions {
  agent: AgentConfig;
  tools: ToolDefinition[];
  context?: {
    channel?: string;
    isGroup?: boolean;
    workingDirectory?: string;
  };
}

export function buildSystemPrompt(options: SystemPromptOptions): string {
  const parts: string[] = [];

  // 1. 基础系统提示
  parts.push(BASE_SYSTEM_PROMPT);

  // 2. 身份信息
  if (options.agent.identity) {
    parts.push(`\n## Identity\n`);
    parts.push(`Name: ${options.agent.identity.name}`);
    if (options.agent.identity.description) {
      parts.push(`Description: ${options.agent.identity.description}`);
    }
  }

  // 3. 工具描述
  if (options.tools.length > 0) {
    parts.push(`\n## Available Tools\n`);
    for (const tool of options.tools) {
      parts.push(`- ${tool.name}: ${tool.description}`);
    }
  }

  // 4. 上下文信息
  if (options.context) {
    parts.push(`\n## Context\n`);
    if (options.context.channel) {
      parts.push(`Channel: ${options.context.channel}`);
    }
    if (options.context.isGroup) {
      parts.push(`Type: Group conversation`);
    }
    if (options.context.workingDirectory) {
      parts.push(`Working Directory: ${options.context.workingDirectory}`);
    }
  }

  return parts.join("\n");
}
```

```typescript
// src/agents/bash-tools.ts

import { z } from "zod";
import { spawn } from "child_process";

export const BashToolSchema = z.object({
  name: z.literal("bash"),
  description: z.string(),
  inputSchema: z.object({
    command: z.string(),
    workingDirectory: z.string().optional(),
    timeout: z.number().optional(),
  }),
});

export interface BashToolOptions {
  command: string;
  workingDirectory?: string;
  timeout?: number;
  onOutput?: (chunk: string) => void;
}

export async function executeBashTool(
  options: BashToolOptions
): Promise<BashToolResult> {
  return new Promise((resolve, reject) => {
    const process = spawn("bash", ["-c", options.command], {
      cwd: options.workingDirectory,
      timeout: options.timeout ?? 120000,
    });

    let stdout = "";
    let stderr = "";

    process.stdout.on("data", (data) => {
      stdout += data.toString();
      options.onOutput?.(data.toString());
    });

    process.stderr.on("data", (data) => {
      stderr += data.toString();
    });

    process.on("close", (code) => {
      resolve({
        exitCode: code ?? 0,
        stdout,
        stderr,
      });
    });

    process.on("error", reject);
  });
}

export interface BashToolResult {
  exitCode: number;
  stdout: string;
  stderr: string;
}
```

#### 3.2.3 Agent执行器设计

```typescript
// src/agents/runner.ts

export interface AgentRunnerOptions {
  agent: AgentConfig;
  session: SessionEntry;
  transcript: Transcript;
  message: ContentBlock[];
  runId: string;
  broadcaster: GatewayBroadcaster;
  thinkingLevel?: ThinkingLevel;
}

export class AgentRunner {
  private options: AgentRunnerOptions;
  private modelManager: ModelManager;
  private toolRegistry: ToolRegistry;
  private aborted: boolean = false;

  constructor(options: AgentRunnerOptions);

  async start(): Promise<void> {
    try {
      // 1. 构建系统提示
      const systemPrompt = buildSystemPrompt({
        agent: this.options.agent,
        tools: this.toolRegistry.getTools(),
      });

      // 2. 准备消息历史
      const messages = await this.prepareMessages();

      // 3. 添加用户消息
      messages.push({
        role: "user",
        content: this.options.message,
      });

      // 4. 执行循环
      await this.runLoop(systemPrompt, messages);

    } catch (error) {
      this.broadcastError(error);
    }
  }

  private async runLoop(
    systemPrompt: string,
    messages: Message[]
  ): Promise<void> {
    while (!this.aborted) {
      // 创建completion
      const stream = await this.modelManager.createCompletion({
        systemPrompt,
        messages,
        tools: this.toolRegistry.getToolDefinitions(),
        maxTokens: this.options.agent.model.maxTokens,
      });

      // 处理流式输出
      const blocks: Block[] = [];
      for await (const block of stream) {
        if (this.aborted) break;

        blocks.push(block);
        this.broadcastBlock(block);

        // 处理工具调用
        if (block.type === "tool_use") {
          const result = await this.executeTool(block);
          messages.push({
            role: "assistant",
            content: [block],
          });
          messages.push({
            role: "user",
            content: [{
              type: "tool_result",
              tool_use_id: block.id,
              content: result,
            }],
          });
          continue;
        }
      }

      // 检查是否需要继续循环
      const hasToolUse = blocks.some(b => b.type === "tool_use");
      if (!hasToolUse) {
        // 完成，保存并广播
        await this.saveTranscript(messages);
        this.broadcastComplete(blocks);
        break;
      }
    }
  }

  abort(): void {
    this.aborted = true;
  }

  private async executeTool(toolUse: ToolUseBlock): Promise<unknown>;
  private async prepareMessages(): Promise<Message[]>;
  private broadcastBlock(block: Block): void;
  private broadcastComplete(blocks: Block[]): void;
  private broadcastError(error: unknown): void;
  private async saveTranscript(messages: Message[]): Promise<void>;
}
```

---

### 3.3 渠道模块

#### 3.3.1 渠道适配器接口

```typescript
// src/channels/types.ts

export interface ChannelAdapter {
  name: string;
  type: ChannelType;

  // 生命周期
  connect(config: ChannelConfig): Promise<void>;
  disconnect(): Promise<void>;
  isConnected(): boolean;

  // 消息处理
  onMessage(handler: InboundMessageHandler): void;
  sendMessage(target: OutboundTarget, message: OutboundMessage): Promise<void>;

  // 状态
  getStatus(): ChannelStatus;
  getAccounts(): AccountInfo[];
}

export interface InboundMessage {
  messageId: string;
  channel: ChannelType;
  chatType: "dm" | "group" | "channel";
  peerId: string;
  senderId: string;
  senderName?: string;
  content: ContentBlock[];
  timestamp: number;
  replyTo?: string;
  mentions?: string[];
  raw?: unknown;
}

export interface OutboundMessage {
  content: ContentBlock[];
  replyTo?: string;
}

export interface OutboundTarget {
  channel: ChannelType;
  chatType: "dm" | "group" | "channel";
  peerId: string;
  accountId?: string;
}

export type InboundMessageHandler = (message: InboundMessage) => Promise<void>;
```

#### 3.3.2 WhatsApp适配器

```typescript
// extensions/whatsapp/src/adapter.ts

import makeWASocket, {
  DisconnectReason,
  useMultiFileAuthState,
} from "@whiskeysockets/baileys";

export class WhatsAppAdapter implements ChannelAdapter {
  name = "whatsapp";
  type: ChannelType = "whatsapp";

  private socket: ReturnType<typeof makeWASocket> | null = null;
  private authState: Awaited<ReturnType<typeof useMultiFileAuthState>>;
  private messageHandler: InboundMessageHandler | null = null;
  private config: WhatsAppConfig;

  constructor(config: WhatsAppConfig);

  async connect(): Promise<void> {
    // 1. 加载认证状态
    this.authState = await useMultiFileAuthState(this.config.authPath);

    // 2. 创建socket
    this.socket = makeWASocket({
      auth: this.authState.state,
      printQRInTerminal: true,
      // ...其他配置
    });

    // 3. 注册事件处理
    this.socket.ev.on("connection.update", this.handleConnectionUpdate);
    this.socket.ev.on("messages.upsert", this.handleMessagesUpsert);
    this.socket.ev.on("creds.update", this.authState.saveCreds);
  }

  async disconnect(): Promise<void> {
    this.socket?.end();
    this.socket = null;
  }

  isConnected(): boolean {
    return this.socket !== null;
  }

  onMessage(handler: InboundMessageHandler): void {
    this.messageHandler = handler;
  }

  async sendMessage(
    target: OutboundTarget,
    message: OutboundMessage
  ): Promise<void> {
    if (!this.socket) throw new Error("Not connected");

    const jid = this.resolveJid(target);

    for (const block of message.content) {
      if (block.type === "text") {
        await this.socket.sendMessage(jid, {
          text: this.formatText(block.text),
        });
      } else if (block.type === "image") {
        await this.socket.sendMessage(jid, {
          image: Buffer.from(block.source.data, "base64"),
          mimetype: block.source.media_type,
        });
      }
      // ...其他类型
    }
  }

  private handleConnectionUpdate = async (update: ConnectionUpdate) => {
    const { connection, lastDisconnect, qr } = update;

    if (qr) {
      // 广播二维码
      this.broadcastQR(qr);
    }

    if (connection === "close") {
      const reason = lastDisconnect?.error?.output?.statusCode;
      if (reason !== DisconnectReason.loggedOut) {
        // 重连
        await this.connect();
      }
    }
  };

  private handleMessagesUpsert = async (update: MessagesUpsert) => {
    for (const msg of update.messages) {
      if (msg.key.fromMe) continue;

      const inbound = this.convertToInbound(msg);
      await this.messageHandler?.(inbound);
    }
  };

  private convertToInbound(msg: WAMessage): InboundMessage;
  private resolveJid(target: OutboundTarget): string;
  private formatText(text: string): string;
}
```

#### 3.3.3 Telegram适配器

```typescript
// extensions/telegram/src/adapter.ts

import { Bot, Context } from "grammy";

export class TelegramAdapter implements ChannelAdapter {
  name = "telegram";
  type: ChannelType = "telegram";

  private bot: Bot | null = null;
  private messageHandler: InboundMessageHandler | null = null;
  private config: TelegramConfig;

  constructor(config: TelegramConfig);

  async connect(): Promise<void> {
    this.bot = new Bot(this.config.token);

    // 注册消息处理
    this.bot.on("message", this.handleMessage);

    // 启动轮询或webhook
    if (this.config.webhook) {
      await this.bot.api.setWebhook(this.config.webhook.url);
    } else {
      this.bot.start();
    }
  }

  async disconnect(): Promise<void> {
    await this.bot?.stop();
    this.bot = null;
  }

  isConnected(): boolean {
    return this.bot !== null;
  }

  onMessage(handler: InboundMessageHandler): void {
    this.messageHandler = handler;
  }

  async sendMessage(
    target: OutboundTarget,
    message: OutboundMessage
  ): Promise<void> {
    if (!this.bot) throw new Error("Not connected");

    const chatId = target.peerId;

    for (const block of message.content) {
      if (block.type === "text") {
        await this.bot.api.sendMessage(chatId, block.text, {
          parse_mode: "Markdown",
        });
      } else if (block.type === "image") {
        await this.bot.api.sendPhoto(chatId, Buffer.from(block.source.data, "base64"));
      }
    }
  }

  private handleMessage = async (ctx: Context) => {
    const inbound = this.convertToInbound(ctx);
    await this.messageHandler?.(inbound);
  };

  private convertToInbound(ctx: Context): InboundMessage;
}
```

---

### 3.4 Session 会话模块

#### 3.4.1 会话管理器

```typescript
// src/sessions/manager.ts

export interface SessionManagerOptions {
  storagePath: string;
  config: SessionConfig;
}

export class SessionManager {
  private sessions: Map<string, SessionEntry>;
  private storagePath: string;
  private config: SessionConfig;

  constructor(options: SessionManagerOptions);

  async getSession(sessionKey: string): Promise<SessionEntry | null> {
    // 1. 检查内存缓存
    if (this.sessions.has(sessionKey)) {
      return this.sessions.get(sessionKey)!;
    }

    // 2. 从文件加载
    const entry = await this.loadFromFile(sessionKey);
    if (entry) {
      this.sessions.set(sessionKey, entry);
    }

    return entry;
  }

  async createSession(sessionKey: string): Promise<SessionEntry> {
    const entry: SessionEntry = {
      sessionId: generateUUID(),
      sessionKey,
      updatedAt: Date.now(),
      sendPolicy: "allow",
    };

    this.sessions.set(sessionKey, entry);
    await this.saveToFile(entry);

    return entry;
  }

  async updateSession(
    sessionKey: string,
    patch: Partial<SessionEntry>
  ): Promise<SessionEntry> {
    const entry = await this.getSession(sessionKey);
    if (!entry) {
      throw new Error(`Session not found: ${sessionKey}`);
    }

    Object.assign(entry, patch, { updatedAt: Date.now() });
    await this.saveToFile(entry);

    return entry;
  }

  async deleteSession(sessionKey: string): Promise<void> {
    this.sessions.delete(sessionKey);
    await this.deleteFile(sessionKey);
  }

  async listSessions(filter?: SessionFilter): Promise<SessionEntry[]> {
    const files = await this.listSessionFiles();
    const entries: SessionEntry[] = [];

    for (const file of files) {
      const entry = await this.loadFromFile(file);
      if (entry && this.matchesFilter(entry, filter)) {
        entries.push(entry);
      }
    }

    return entries;
  }

  private async loadFromFile(sessionKey: string): Promise<SessionEntry | null>;
  private async saveToFile(entry: SessionEntry): Promise<void>;
  private async deleteFile(sessionKey: string): Promise<void>;
  private async listSessionFiles(): Promise<string[]>;
  private matchesFilter(entry: SessionEntry, filter?: SessionFilter): boolean;
}
```

#### 3.4.2 Transcript存储

```typescript
// src/sessions/transcript.ts

export interface TranscriptOptions {
  storagePath: string;
  sessionKey: string;
}

export class Transcript {
  private filePath: string;
  private messages: Message[] = [];
  private loaded: boolean = false;

  constructor(options: TranscriptOptions);

  async load(): Promise<void> {
    if (this.loaded) return;

    const content = await fs.readFile(this.filePath, "utf-8").catch(() => "");
    const lines = content.split("\n").filter(Boolean);

    this.messages = lines.map((line) => JSON.parse(line));
    this.loaded = true;
  }

  async append(message: Message): Promise<void> {
    this.messages.push(message);
    await fs.appendFile(
      this.filePath,
      JSON.stringify(message) + "\n"
    );
  }

  async clear(): Promise<void> {
    this.messages = [];
    await fs.writeFile(this.filePath, "");
  }

  getMessages(limit?: number): Message[] {
    if (limit) {
      return this.messages.slice(-limit);
    }
    return [...this.messages];
  }

  getRecentMessages(tokenLimit: number): Message[] {
    // 从后向前取，直到达到token限制
    const result: Message[] = [];
    let totalTokens = 0;

    for (let i = this.messages.length - 1; i >= 0; i--) {
      const msg = this.messages[i];
      const tokens = estimateTokens(msg);

      if (totalTokens + tokens > tokenLimit) break;

      result.unshift(msg);
      totalTokens += tokens;
    }

    return result;
  }
}
```

---

### 3.5 配置模块

#### 3.5.1 配置加载器

```typescript
// src/config/config.ts

import JSON5 from "json5";
import { z } from "zod";

export const ConfigSchema = z.object({
  agents: z.object({
    default: z.string(),
    list: z.array(AgentConfigSchema),
  }),
  channels: z.record(ChannelConfigSchema),
  session: SessionConfigSchema,
  messages: MessagesConfigSchema,
  gateway: GatewayConfigSchema,
  tools: ToolsConfigSchema.optional(),
  models: ModelsConfigSchema.optional(),
});

export type OpenClawConfig = z.infer<typeof ConfigSchema>;

export interface ConfigLoaderOptions {
  configPath: string;
  envPrefix?: string;
}

export class ConfigLoader {
  private configPath: string;
  private envPrefix: string;
  private cachedConfig: OpenClawConfig | null = null;
  private fileHash: string | null = null;

  constructor(options: ConfigLoaderOptions);

  async load(): Promise<OpenClawConfig> {
    // 1. 读取文件
    const content = await fs.readFile(this.configPath, "utf-8");
    const hash = crypto.createHash("sha256").update(content).digest("hex");

    // 2. 检查缓存
    if (this.cachedConfig && this.fileHash === hash) {
      return this.cachedConfig;
    }

    // 3. 解析JSON5
    const raw = JSON5.parse(content);

    // 4. 应用环境变量
    const withEnv = this.applyEnvironmentVariables(raw);

    // 5. 应用默认值
    const withDefaults = this.applyDefaults(withEnv);

    // 6. 验证
    const validated = ConfigSchema.parse(withDefaults);

    // 7. 缓存
    this.cachedConfig = validated;
    this.fileHash = hash;

    return validated;
  }

  async save(config: OpenClawConfig): Promise<void> {
    // 1. 验证
    ConfigSchema.parse(config);

    // 2. 序列化
    const content = JSON.stringify(config, null, 2);

    // 3. 写入文件
    await fs.writeFile(this.configPath, content);

    // 4. 更新缓存
    this.cachedConfig = config;
    this.fileHash = crypto.createHash("sha256").update(content).digest("hex");
  }

  getConfigHash(): string | null {
    return this.fileHash;
  }

  private applyEnvironmentVariables(config: unknown): unknown;
  private applyDefaults(config: unknown): unknown;
}
```

#### 3.5.2 配置Schema定义

```typescript
// src/config/schema.ts

import { z } from "zod";

export const AgentConfigSchema = z.object({
  id: z.string(),
  model: z.object({
    provider: z.enum(["anthropic", "openai", "gemini", "bedrock", "ollama"]),
    model: z.string(),
    apiKey: z.string().optional(),
    baseUrl: z.string().url().optional(),
    maxTokens: z.number().positive().optional(),
    temperature: z.number().min(0).max(2).optional(),
  }),
  fallbackModels: z.array(z.object({
    provider: z.enum(["anthropic", "openai", "gemini", "bedrock", "ollama"]),
    model: z.string(),
  })).optional(),
  identity: z.object({
    name: z.string(),
    description: z.string().optional(),
  }).optional(),
  workspace: z.string().optional(),
  groupChat: z.object({
    systemPrompt: z.string().optional(),
    historyLimit: z.number().positive().optional(),
    mentionRequired: z.boolean().optional(),
  }).optional(),
  tools: z.object({
    policies: z.array(ToolPolicySchema).optional(),
    disabled: z.array(z.string()).optional(),
  }).optional(),
});

export const ChannelConfigSchema = z.object({
  enabled: z.boolean().default(false),
  accounts: z.array(AccountConfigSchema).optional(),
  dmPolicy: z.enum(["pairing", "allowlist", "open"]).optional(),
  groupPolicy: z.enum(["mention-gating", "allowlist", "open", "disabled"]).optional(),
  allowlist: z.array(z.string()).optional(),
  denylist: z.array(z.string()).optional(),
});

export const SessionConfigSchema = z.object({
  scope: z.enum(["per-sender", "global"]).default("per-sender"),
  resetMode: z.enum(["daily", "idle", "manual"]).default("idle"),
  idleTimeout: z.number().positive().optional(),
  historyLimit: z.number().positive().optional(),
});

export const GatewayConfigSchema = z.object({
  host: z.string().default("127.0.0.1"),
  port: z.number().default(18789),
  httpPort: z.number().default(18790),
  auth: z.object({
    mode: z.enum(["token", "password"]).default("token"),
    token: z.string().optional(),
    password: z.string().optional(),
    allowTailscale: z.boolean().default(false),
  }).optional(),
});
```

---

### 3.6 路由模块

#### 3.6.1 路由解析器

```typescript
// src/routing/resolver.ts

export interface RouteResolutionOptions {
  channel: ChannelType;
  chatType: "dm" | "group" | "channel";
  peerId: string;
  senderId: string;
  config: OpenClawConfig;
}

export interface RouteResolutionResult {
  sessionKey: string;
  agentId: string;
  allowed: boolean;
  denyReason?: string;
}

export class RouteResolver {
  private config: OpenClawConfig;

  constructor(config: OpenClawConfig);

  resolve(options: RouteResolutionOptions): RouteResolutionResult {
    // 1. 构造会话键
    const sessionKey = this.buildSessionKey(options);

    // 2. 检查访问权限
    const accessCheck = this.checkAccess(options);
    if (!accessCheck.allowed) {
      return {
        sessionKey,
        agentId: this.config.agents.default,
        allowed: false,
        denyReason: accessCheck.reason,
      };
    }

    // 3. 解析Agent
    const agentId = this.resolveAgent(options);

    return {
      sessionKey,
      agentId,
      allowed: true,
    };
  }

  private buildSessionKey(options: RouteResolutionOptions): string {
    const { channel, chatType, peerId } = options;

    if (this.config.session.scope === "global") {
      return `${channel}:${chatType}:global`;
    }

    return `${channel}:${chatType}:${peerId}`;
  }

  private checkAccess(
    options: RouteResolutionOptions
  ): { allowed: boolean; reason?: string } {
    const channelConfig = this.config.channels[options.channel];
    if (!channelConfig?.enabled) {
      return { allowed: false, reason: "Channel disabled" };
    }

    if (options.chatType === "dm") {
      return this.checkDmAccess(options, channelConfig);
    } else {
      return this.checkGroupAccess(options, channelConfig);
    }
  }

  private checkDmAccess(
    options: RouteResolutionOptions,
    channelConfig: ChannelConfig
  ): { allowed: boolean; reason?: string } {
    const policy = channelConfig.dmPolicy ?? "allowlist";

    switch (policy) {
      case "open":
        return { allowed: true };

      case "allowlist":
        if (channelConfig.allowlist?.includes(options.senderId)) {
          return { allowed: true };
        }
        return { allowed: false, reason: "Not in allowlist" };

      case "pairing":
        if (channelConfig.allowlist?.includes(options.senderId)) {
          return { allowed: true };
        }
        return { allowed: false, reason: "pairing_required" };
    }
  }

  private checkGroupAccess(
    options: RouteResolutionOptions,
    channelConfig: ChannelConfig
  ): { allowed: boolean; reason?: string };

  private resolveAgent(options: RouteResolutionOptions): string;
}
```

---

### 3.7 Cron 定时任务模块

```typescript
// src/cron/service.ts

import { Cron } from "croner";

export interface CronJob {
  id: string;
  name: string;
  schedule: string;
  type: "heartbeat" | "session-reset" | "custom";
  enabled: boolean;
  config?: unknown;
}

export interface CronServiceOptions {
  config: OpenClawConfig;
  storagePath: string;
  agentRunner: AgentRunner;
}

export class CronService {
  private jobs: Map<string, Cron>;
  private config: CronJob[];
  private agentRunner: AgentRunner;

  constructor(options: CronServiceOptions);

  async start(): Promise<void> {
    for (const job of this.config) {
      if (!job.enabled) continue;

      const cron = new Cron(job.schedule, async () => {
        await this.executeJob(job);
      });

      this.jobs.set(job.id, cron);
    }
  }

  async stop(): Promise<void> {
    for (const cron of this.jobs.values()) {
      cron.stop();
    }
    this.jobs.clear();
  }

  async runJob(jobId: string): Promise<void> {
    const job = this.config.find((j) => j.id === jobId);
    if (!job) throw new Error(`Job not found: ${jobId}`);

    await this.executeJob(job);
  }

  private async executeJob(job: CronJob): Promise<void> {
    switch (job.type) {
      case "heartbeat":
        await this.executeHeartbeat(job);
        break;
      case "session-reset":
        await this.executeSessionReset(job);
        break;
      case "custom":
        await this.executeCustomJob(job);
        break;
    }
  }

  private async executeHeartbeat(job: CronJob): Promise<void>;
  private async executeSessionReset(job: CronJob): Promise<void>;
  private async executeCustomJob(job: CronJob): Promise<void>;
}
```

---

## 4. 数据库设计

### 4.1 存储结构

OpenClaw使用文件系统存储，不使用传统数据库。

```
~/.openclaw/
├── config.json                    # 主配置 (JSON5)
│
├── credentials/                   # 凭证存储 (加密JSON)
│   ├── anthropic.json
│   ├── openai.json
│   ├── google.json
│   └── ...
│
├── state/
│   ├── sessions/                  # 会话存储 (JSONL)
│   │   ├── index.json             # 会话索引
│   │   ├── whatsapp_dm_+86xxx.jsonl
│   │   ├── telegram_group_-100xxx.jsonl
│   │   └── ...
│   │
│   ├── devices/                   # 设备存储
│   │   └── devices.json
│   │
│   ├── pairing/                   # 配对码
│   │   └── pending.json
│   │
│   └── memory/                    # 向量存储
│       └── vectors.db             # sqlite-vec
│
├── logs/                          # 日志文件
│   ├── gateway.log
│   └── gateway.log.1
│
├── channels/                      # 渠道状态
│   ├── whatsapp/
│   │   └── auth/                  # Baileys认证状态
│   ├── telegram/
│   └── ...
│
└── plugins/                       # 插件目录
    ├── skill-weather/
    └── ...
```

### 4.2 数据格式定义

#### 4.2.1 配置文件 (config.json)

```json5
{
  // Agent配置
  "agents": {
    "default": "main",
    "list": [
      {
        "id": "main",
        "model": {
          "provider": "anthropic",
          "model": "claude-3-5-sonnet-20241022",
          "maxTokens": 8192
        },
        "fallbackModels": [
          { "provider": "openai", "model": "gpt-4o" }
        ],
        "identity": {
          "name": "Assistant",
          "description": "A helpful AI assistant"
        }
      }
    ]
  },

  // 渠道配置
  "channels": {
    "whatsapp": {
      "enabled": true,
      "dmPolicy": "pairing",
      "groupPolicy": "mention-gating",
      "allowlist": ["+8613800138000"]
    },
    "telegram": {
      "enabled": true,
      "dmPolicy": "allowlist"
    }
  },

  // 会话配置
  "session": {
    "scope": "per-sender",
    "resetMode": "idle",
    "idleTimeout": 3600,
    "historyLimit": 100
  },

  // 消息配置
  "messages": {
    "historyLimit": 50,
    "chunkLimit": 4000,
    "responsePrefix": ""
  },

  // 网关配置
  "gateway": {
    "host": "127.0.0.1",
    "port": 18789,
    "httpPort": 18790,
    "auth": {
      "mode": "token"
      // token从环境变量读取
    }
  }
}
```

#### 4.2.2 会话文件 (*.jsonl)

```jsonl
{"version":"1","sessionId":"abc123","createdAt":1704067200000,"workingDirectory":"/home/user"}
{"role":"user","content":[{"type":"text","text":"Hello"}],"timestamp":1704067260000}
{"role":"assistant","content":[{"type":"text","text":"Hi! How can I help?"}],"timestamp":1704067262000}
{"role":"user","content":[{"type":"text","text":"What's the weather?"}],"timestamp":1704067300000}
{"role":"assistant","content":[{"type":"tool_use","id":"tool_1","name":"weather","input":{"city":"Beijing"}}],"timestamp":1704067301000}
{"role":"user","content":[{"type":"tool_result","tool_use_id":"tool_1","content":"Sunny, 25°C"}],"timestamp":1704067302000}
{"role":"assistant","content":[{"type":"text","text":"It's sunny in Beijing, 25°C."}],"timestamp":1704067303000}
```

#### 4.2.3 设备文件 (devices.json)

```json
{
  "devices": [
    {
      "deviceId": "device-uuid-123",
      "name": "MacBook Pro",
      "publicKey": "base64-encoded-public-key",
      "addedAt": 1704067200000,
      "lastSeenAt": 1704153600000,
      "approved": true
    }
  ],
  "pendingPairings": [
    {
      "deviceId": "device-uuid-456",
      "publicKey": "base64-encoded-public-key",
      "requestedAt": 1704153600000,
      "expiresAt": 1704157200000
    }
  ]
}
```

---

## 5. 接口详细设计

### 5.1 WebSocket协议

#### 5.1.1 连接握手

```
Client                                    Server
   |                                         |
   |  ---- WebSocket Upgrade Request ---->   |
   |                                         |
   |  <---- 101 Switching Protocols -----    |
   |                                         |
   |  <---- event: connect.challenge -----   |
   |         { nonce: "xxx" }                |
   |                                         |
   |  ---- req: connect ------------------> |
   |       { version, clientId, role,        |
   |         scopes, deviceSignature,        |
   |         devicePayload, token }          |
   |                                         |
   |  <---- res: hello-ok ----------------   |
   |       { deviceToken, config }           |
   |                                         |
   |  ==== Connection Established ====       |
```

#### 5.1.2 请求/响应模式

```
Client                                    Server
   |                                         |
   |  ---- req: chat.send ----------------> |
   |       { sessionKey, runId, message }    |
   |                                         |
   |  <---- res: chat.send ---------------   |
   |       { ok: true, payload: {runId} }    |
   |                                         |
   |  <---- event: chat -----------------    |
   |       { state: "delta", delta: "Hi" }   |
   |                                         |
   |  <---- event: chat -----------------    |
   |       { state: "delta", delta: "!" }    |
   |                                         |
   |  <---- event: chat -----------------    |
   |       { state: "final", blocks: [...] } |
```

### 5.2 RPC方法详细规格

#### 5.2.1 chat.send

```typescript
// 请求
interface ChatSendParams {
  sessionKey: string;          // 会话键
  runId: string;               // 运行ID (UUID)
  message: ContentBlock[];     // 消息内容
  agentId?: string;            // 可选Agent ID
  thinkingLevel?: "none" | "low" | "medium" | "high";
}

// 响应
interface ChatSendResult {
  runId: string;
}

// 事件
interface ChatEvent {
  state: "delta" | "thinking" | "tool_use" | "tool_result" | "final" | "error" | "aborted";
  runId: string;
  delta?: string;
  blocks?: Block[];
  error?: string;
}
```

#### 5.2.2 config.get

```typescript
// 请求
interface ConfigGetParams {
  // 无参数
}

// 响应
interface ConfigGetResult {
  config: OpenClawConfig;
  hash: string;               // 配置文件hash
  schema: JSONSchema;         // 配置Schema
}
```

#### 5.2.3 channels.status

```typescript
// 请求
interface ChannelsStatusParams {
  // 无参数
}

// 响应
interface ChannelsStatusResult {
  channels: {
    [channelType: string]: {
      enabled: boolean;
      connected: boolean;
      accounts: AccountInfo[];
      error?: string;
    };
  };
}
```

### 5.3 HTTP API

#### 5.3.1 Webhook端点

```
POST /hooks/wake
Content-Type: application/json
Authorization: Bearer <token>

{
  "source": "external",
  "payload": { ... }
}

Response: 200 OK
{ "ok": true }
```

#### 5.3.2 健康检查

```
GET /health

Response: 200 OK
{
  "status": "healthy",
  "uptime": 3600,
  "version": "2026.2.1"
}
```

---

## 6. 前端详细设计

### 6.1 组件架构

```typescript
// ui/src/ui/app.ts

@customElement("openclaw-app")
export class OpenClawApp extends LitElement {
  // 连接状态
  @state() connected: boolean = false;
  @state() hello: HelloResponse | null = null;
  @state() lastError: string | null = null;

  // 导航状态
  @state() tab: Tab = "chat";
  @state() settings: UiSettings = loadSettings();

  // 聊天状态
  @state() chatMessages: Message[] = [];
  @state() chatStream: string = "";
  @state() chatSending: boolean = false;
  @state() chatRunId: string | null = null;

  // 配置状态
  @state() configRaw: string = "";
  @state() configForm: ConfigForm | null = null;
  @state() configSaving: boolean = false;

  // 其他状态...
  @state() channelsSnapshot: ChannelsStatus | null = null;
  @state() sessionsResult: SessionsResult | null = null;
  @state() cronJobs: CronJob[] = [];
  @state() logsEntries: LogEntry[] = [];

  // 网关客户端
  private client: GatewayBrowserClient | null = null;

  // 生命周期
  connectedCallback(): void {
    super.connectedCallback();
    this.initialize();
  }

  disconnectedCallback(): void {
    super.disconnectedCallback();
    this.cleanup();
  }

  // 渲染
  createRenderRoot() {
    return this; // 不使用Shadow DOM
  }

  render() {
    return renderApp(this);
  }
}
```

### 6.2 视图设计

```typescript
// ui/src/ui/views/chat.ts

export function renderChatView(state: AppViewState): TemplateResult {
  return html`
    <div class="chat-layout">
      <div class="chat-main">
        <div class="chat-messages" @scroll=${state.onChatScroll}>
          ${state.chatMessages.map((msg, i) =>
            renderMessageGroup(msg, i, state)
          )}
          ${state.chatStream ? renderStreamingGroup(state) : nothing}
        </div>

        <div class="chat-input-area">
          <div class="chat-attachments">
            ${state.chatAttachments.map(renderAttachment)}
          </div>

          <div class="chat-input-row">
            <textarea
              class="chat-input"
              placeholder="Type a message..."
              @keydown=${state.onChatKeyDown}
              .value=${state.chatInput}
            ></textarea>

            <button
              class="chat-send-btn"
              ?disabled=${state.chatSending}
              @click=${state.onChatSend}
            >
              ${state.chatSending ? "Sending..." : "Send"}
            </button>
          </div>
        </div>
      </div>

      ${state.showToolSidebar
        ? html`
            <div class="chat-sidebar">
              ${renderToolOutputSidebar(state)}
            </div>
          `
        : nothing}
    </div>
  `;
}
```

### 6.3 Gateway客户端

```typescript
// ui/src/ui/gateway.ts

export interface GatewayBrowserClientOptions {
  url: string;
  token?: string;
  onHello: (hello: HelloResponse) => void;
  onEvent: (event: EventFrame) => void;
  onDisconnect: (reason: string) => void;
  onError: (error: Error) => void;
}

export class GatewayBrowserClient {
  private ws: WebSocket | null = null;
  private pending: Map<string, PendingRequest> = new Map();
  private connectNonce: string | null = null;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 10;

  constructor(private options: GatewayBrowserClientOptions);

  async start(): Promise<void> {
    this.ws = new WebSocket(this.options.url);

    this.ws.onopen = () => {
      this.reconnectAttempts = 0;
    };

    this.ws.onmessage = (event) => {
      this.handleMessage(event.data);
    };

    this.ws.onclose = (event) => {
      this.handleClose(event);
    };

    this.ws.onerror = (event) => {
      this.options.onError(new Error("WebSocket error"));
    };
  }

  stop(): void {
    this.ws?.close();
    this.ws = null;
    this.pending.clear();
  }

  async request<T>(method: string, params?: unknown): Promise<T> {
    return new Promise((resolve, reject) => {
      const id = crypto.randomUUID();
      const frame: RequestFrame = {
        type: "req",
        id,
        method,
        params,
      };

      this.pending.set(id, { resolve, reject, timeout: null });

      // 设置超时
      const timeout = setTimeout(() => {
        this.pending.delete(id);
        reject(new Error("Request timeout"));
      }, 30000);

      this.pending.get(id)!.timeout = timeout;

      this.ws?.send(JSON.stringify(frame));
    });
  }

  private handleMessage(data: string): void {
    const frame = JSON.parse(data);

    switch (frame.type) {
      case "event":
        if (frame.event === "connect.challenge") {
          this.connectNonce = frame.payload.nonce;
          this.sendConnect();
        } else {
          this.options.onEvent(frame);
        }
        break;

      case "res":
        this.handleResponse(frame);
        break;
    }
  }

  private handleResponse(frame: ResponseFrame): void {
    const pending = this.pending.get(frame.id);
    if (!pending) return;

    clearTimeout(pending.timeout!);
    this.pending.delete(frame.id);

    if (frame.ok) {
      pending.resolve(frame.payload);
    } else {
      pending.reject(new Error(frame.error?.message ?? "Unknown error"));
    }
  }

  private async sendConnect(): Promise<void> {
    // 设备认证逻辑
    const deviceIdentity = await loadOrCreateDeviceIdentity();
    const payload = buildDeviceAuthPayload({
      deviceId: deviceIdentity.deviceId,
      clientId: "openclaw-control-ui",
      role: "operator",
      scopes: ["operator.admin"],
      nonce: this.connectNonce,
    });

    const signature = await signDevicePayload(deviceIdentity.privateKey, payload);

    await this.request("connect", {
      ...payload,
      deviceSignature: signature,
    });
  }

  private handleClose(event: CloseEvent): void {
    this.options.onDisconnect(event.reason);

    // 自动重连
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
      this.reconnectAttempts++;
      setTimeout(() => this.start(), delay);
    }
  }
}
```

### 6.4 样式设计

```css
/* ui/src/styles/base.css */

:root {
  /* 颜色系统 */
  --bg: #12141a;
  --bg-accent: #14161d;
  --bg-elevated: #1a1d25;
  --bg-hover: #262a35;

  --text: #e4e4e7;
  --text-strong: #fafafa;
  --muted: #71717a;

  --accent: #ff5c5c;
  --accent-hover: #ff7070;
  --accent-glow: rgba(255, 92, 92, 0.25);

  --border: #27272a;
  --border-strong: #3f3f46;

  --success: #22c55e;
  --warning: #f59e0b;
  --error: #ef4444;

  /* 字体 */
  --font-sans: "Space Grotesk", -apple-system, BlinkMacSystemFont, sans-serif;
  --font-mono: "JetBrains Mono", "Fira Code", monospace;

  /* 间距 */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;

  /* 圆角 */
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;

  /* 阴影 */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.2);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.3);
  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.4);
}

/* 浅色主题 */
[data-theme="light"] {
  --bg: #ffffff;
  --bg-accent: #f4f4f5;
  --bg-elevated: #fafafa;
  --bg-hover: #e4e4e7;

  --text: #18181b;
  --text-strong: #09090b;
  --muted: #71717a;

  --border: #e4e4e7;
  --border-strong: #d4d4d8;
}

/* 重置 */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: var(--font-sans);
  background: var(--bg);
  color: var(--text);
  line-height: 1.6;
}
```

```css
/* ui/src/styles/layout.css */

.shell {
  display: grid;
  grid-template-areas:
    "topbar topbar"
    "nav content";
  grid-template-columns: 240px 1fr;
  grid-template-rows: 56px 1fr;
  height: 100vh;
}

.topbar {
  grid-area: topbar;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 var(--spacing-md);
  background: var(--bg-accent);
  border-bottom: 1px solid var(--border);
}

.nav {
  grid-area: nav;
  display: flex;
  flex-direction: column;
  background: var(--bg-accent);
  border-right: 1px solid var(--border);
  overflow-y: auto;
}

.nav-group {
  padding: var(--spacing-sm) 0;
}

.nav-item {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm) var(--spacing-md);
  color: var(--muted);
  text-decoration: none;
  cursor: pointer;
  transition: all 0.15s ease;
}

.nav-item:hover {
  background: var(--bg-hover);
  color: var(--text);
}

.nav-item.active {
  background: var(--bg-hover);
  color: var(--accent);
}

.content {
  grid-area: content;
  overflow-y: auto;
  padding: var(--spacing-lg);
}

/* 移动端响应式 */
@media (max-width: 768px) {
  .shell {
    grid-template-areas:
      "topbar"
      "content";
    grid-template-columns: 1fr;
  }

  .nav {
    position: fixed;
    left: -240px;
    top: 56px;
    bottom: 0;
    width: 240px;
    z-index: 100;
    transition: left 0.3s ease;
  }

  .nav.open {
    left: 0;
  }
}
```

---

## 7. 移动端设计

### 7.1 iOS/macOS (Swift)

#### 7.1.1 项目结构

```
apps/macos/
├── Package.swift
├── Sources/
│   ├── OpenClawApp.swift          # App入口
│   ├── Views/
│   │   ├── MainView.swift
│   │   ├── ChatView.swift
│   │   ├── SettingsView.swift
│   │   └── ...
│   ├── ViewModels/
│   │   ├── ChatViewModel.swift
│   │   └── ...
│   ├── Services/
│   │   ├── GatewayClient.swift
│   │   ├── DeviceAuth.swift
│   │   └── ...
│   ├── Models/
│   │   ├── Message.swift
│   │   ├── Session.swift
│   │   └── ...
│   └── Utils/
│       └── ...
└── Tests/
```

#### 7.1.2 Gateway客户端

```swift
// Sources/Services/GatewayClient.swift

import Foundation
import Combine

class GatewayClient: ObservableObject {
    @Published var isConnected: Bool = false
    @Published var lastError: String?

    private var webSocketTask: URLSessionWebSocketTask?
    private var pendingRequests: [String: CheckedContinuation<Any, Error>] = [:]
    private var cancellables = Set<AnyCancellable>()

    let url: URL
    let token: String?

    init(url: URL, token: String? = nil) {
        self.url = url
        self.token = token
    }

    func connect() async throws {
        var request = URLRequest(url: url)
        if let token = token {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }

        webSocketTask = URLSession.shared.webSocketTask(with: request)
        webSocketTask?.resume()

        isConnected = true
        startReceiving()
    }

    func disconnect() {
        webSocketTask?.cancel(with: .normalClosure, reason: nil)
        webSocketTask = nil
        isConnected = false
    }

    func request<T: Decodable>(_ method: String, params: Encodable? = nil) async throws -> T {
        let id = UUID().uuidString
        let frame = RequestFrame(type: "req", id: id, method: method, params: params)

        let data = try JSONEncoder().encode(frame)
        try await webSocketTask?.send(.data(data))

        return try await withCheckedThrowingContinuation { continuation in
            pendingRequests[id] = continuation as! CheckedContinuation<Any, Error>
        } as! T
    }

    private func startReceiving() {
        webSocketTask?.receive { [weak self] result in
            switch result {
            case .success(let message):
                self?.handleMessage(message)
                self?.startReceiving()
            case .failure(let error):
                self?.lastError = error.localizedDescription
                self?.isConnected = false
            }
        }
    }

    private func handleMessage(_ message: URLSessionWebSocketTask.Message) {
        // 处理消息...
    }
}
```

### 7.2 Android (Kotlin)

#### 7.2.1 项目结构

```
apps/android/
├── app/
│   ├── build.gradle.kts
│   └── src/main/
│       ├── kotlin/com/openclaw/
│       │   ├── OpenClawApp.kt
│       │   ├── ui/
│       │   │   ├── MainActivity.kt
│       │   │   ├── chat/
│       │   │   │   ├── ChatScreen.kt
│       │   │   │   └── ChatViewModel.kt
│       │   │   ├── settings/
│       │   │   └── ...
│       │   ├── data/
│       │   │   ├── GatewayClient.kt
│       │   │   ├── models/
│       │   │   └── repository/
│       │   └── di/
│       │       └── AppModule.kt
│       ├── res/
│       └── AndroidManifest.xml
├── build.gradle.kts
└── gradle/
```

#### 7.2.2 Gateway客户端

```kotlin
// app/src/main/kotlin/com/openclaw/data/GatewayClient.kt

class GatewayClient(
    private val url: String,
    private val token: String? = null
) {
    private var webSocket: WebSocket? = null
    private val pendingRequests = mutableMapOf<String, CompletableDeferred<Any>>()
    private val _connectionState = MutableStateFlow<ConnectionState>(ConnectionState.Disconnected)
    val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()

    private val _events = MutableSharedFlow<GatewayEvent>()
    val events: SharedFlow<GatewayEvent> = _events.asSharedFlow()

    private val client = OkHttpClient.Builder()
        .pingInterval(30, TimeUnit.SECONDS)
        .build()

    fun connect() {
        val request = Request.Builder()
            .url(url)
            .apply { token?.let { addHeader("Authorization", "Bearer $it") } }
            .build()

        webSocket = client.newWebSocket(request, object : WebSocketListener() {
            override fun onOpen(webSocket: WebSocket, response: Response) {
                _connectionState.value = ConnectionState.Connected
            }

            override fun onMessage(webSocket: WebSocket, text: String) {
                handleMessage(text)
            }

            override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
                _connectionState.value = ConnectionState.Disconnected
            }

            override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
                _connectionState.value = ConnectionState.Error(t.message ?: "Unknown error")
            }
        })
    }

    fun disconnect() {
        webSocket?.close(1000, "User disconnect")
        webSocket = null
    }

    suspend fun <T> request(method: String, params: Any? = null): T {
        val id = UUID.randomUUID().toString()
        val frame = RequestFrame(type = "req", id = id, method = method, params = params)

        val json = Gson().toJson(frame)
        webSocket?.send(json)

        val deferred = CompletableDeferred<Any>()
        pendingRequests[id] = deferred

        return deferred.await() as T
    }

    private fun handleMessage(text: String) {
        val frame = Gson().fromJson(text, Map::class.java)
        when (frame["type"]) {
            "res" -> handleResponse(frame)
            "event" -> handleEvent(frame)
        }
    }

    private fun handleResponse(frame: Map<*, *>) {
        val id = frame["id"] as? String ?: return
        val deferred = pendingRequests.remove(id) ?: return

        if (frame["ok"] == true) {
            deferred.complete(frame["payload"] ?: Unit)
        } else {
            deferred.completeExceptionally(Exception(frame["error"]?.toString()))
        }
    }

    private fun handleEvent(frame: Map<*, *>) {
        // 发射事件...
    }
}

sealed class ConnectionState {
    object Disconnected : ConnectionState()
    object Connecting : ConnectionState()
    object Connected : ConnectionState()
    data class Error(val message: String) : ConnectionState()
}
```

---

## 8. 安全设计

### 8.1 认证设计

#### 8.1.1 Token认证

```typescript
// src/gateway/auth.ts

export function authenticateWithToken(
  providedToken: string,
  expectedToken: string
): boolean {
  // 使用timing-safe比较防止时序攻击
  const provided = Buffer.from(providedToken);
  const expected = Buffer.from(expectedToken);

  if (provided.length !== expected.length) {
    return false;
  }

  return crypto.timingSafeEqual(provided, expected);
}
```

#### 8.1.2 设备认证

```typescript
// src/gateway/device-auth.ts

import { ed25519 } from "@noble/ed25519";

export interface DeviceAuthPayload {
  deviceId: string;
  clientId: string;
  role: string;
  scopes: string[];
  signedAtMs: number;
  nonce: string;
}

export async function verifyDeviceSignature(
  publicKey: Uint8Array,
  payload: string,
  signature: string
): Promise<boolean> {
  const signatureBytes = Buffer.from(signature, "base64");
  const payloadBytes = new TextEncoder().encode(payload);

  return ed25519.verify(signatureBytes, payloadBytes, publicKey);
}

export async function issueDeviceToken(
  deviceId: string,
  scopes: string[]
): Promise<string> {
  const payload = {
    deviceId,
    scopes,
    issuedAt: Date.now(),
    expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000, // 30天
  };

  const secret = await getTokenSecret();
  return jwt.sign(payload, secret);
}
```

### 8.2 SSRF防护

```typescript
// src/infra/net/ssrf.ts

const PRIVATE_IPV4_RANGES = [
  /^10\./,
  /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
  /^192\.168\./,
  /^127\./,
  /^0\./,
];

const PRIVATE_IPV6_RANGES = [
  /^::1$/,
  /^fc00:/i,
  /^fd00:/i,
  /^fe80:/i,
];

const RESTRICTED_HOSTNAMES = new Set([
  "localhost",
  "localhost.localdomain",
  "metadata.google.internal",
  "169.254.169.254", // AWS/GCP metadata
]);

export function isPrivateAddress(address: string): boolean {
  // IPv4检查
  for (const range of PRIVATE_IPV4_RANGES) {
    if (range.test(address)) return true;
  }

  // IPv6检查
  for (const range of PRIVATE_IPV6_RANGES) {
    if (range.test(address)) return true;
  }

  return false;
}

export function isRestrictedHostname(hostname: string): boolean {
  return RESTRICTED_HOSTNAMES.has(hostname.toLowerCase());
}

export async function validateUrl(url: string, trustedIps?: string[]): Promise<void> {
  const parsed = new URL(url);

  // 检查主机名
  if (isRestrictedHostname(parsed.hostname)) {
    throw new Error(`Restricted hostname: ${parsed.hostname}`);
  }

  // DNS解析并检查IP
  const addresses = await dns.resolve(parsed.hostname);
  for (const address of addresses) {
    if (isPrivateAddress(address) && !trustedIps?.includes(address)) {
      throw new Error(`Private IP address not allowed: ${address}`);
    }
  }
}
```

### 8.3 执行批准

```typescript
// src/security/exec-approvals.ts

export interface ExecApprovalRequest {
  id: string;
  toolName: string;
  input: unknown;
  sessionKey: string;
  runId: string;
  requestedAt: number;
  expiresAt: number;
}

export class ExecApprovalManager {
  private pending: Map<string, ExecApprovalRequest> = new Map();
  private resolved: Map<string, boolean> = new Map();

  async requestApproval(
    request: Omit<ExecApprovalRequest, "id" | "requestedAt" | "expiresAt">
  ): Promise<string> {
    const approval: ExecApprovalRequest = {
      ...request,
      id: crypto.randomUUID(),
      requestedAt: Date.now(),
      expiresAt: Date.now() + 5 * 60 * 1000, // 5分钟超时
    };

    this.pending.set(approval.id, approval);

    // 广播批准请求
    this.broadcaster.broadcast({
      event: "exec.approval.requested",
      payload: approval,
    });

    return approval.id;
  }

  async waitForApproval(id: string, timeoutMs: number = 300000): Promise<boolean> {
    const approval = this.pending.get(id);
    if (!approval) throw new Error("Approval not found");

    // 等待批准或超时
    return new Promise((resolve) => {
      const checkInterval = setInterval(() => {
        if (this.resolved.has(id)) {
          clearInterval(checkInterval);
          resolve(this.resolved.get(id)!);
          this.cleanup(id);
        } else if (Date.now() > approval.expiresAt) {
          clearInterval(checkInterval);
          resolve(false);
          this.cleanup(id);
        }
      }, 100);
    });
  }

  resolve(id: string, approved: boolean): void {
    if (!this.pending.has(id)) {
      throw new Error("Approval not found or expired");
    }

    this.resolved.set(id, approved);

    this.broadcaster.broadcast({
      event: "exec.approval.resolved",
      payload: { id, approved },
    });
  }

  private cleanup(id: string): void {
    this.pending.delete(id);
    this.resolved.delete(id);
  }
}
```

---

## 9. 部署设计

### 9.1 Docker部署

#### 9.1.1 Dockerfile

```dockerfile
# Dockerfile
FROM node:22-bookworm AS builder

WORKDIR /app

# 安装pnpm
RUN corepack enable && corepack prepare pnpm@10.23.0 --activate

# 复制依赖文件
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY packages/ ./packages/
COPY extensions/ ./extensions/

# 安装依赖
RUN pnpm install --frozen-lockfile

# 复制源代码
COPY src/ ./src/
COPY ui/ ./ui/
COPY tsconfig.json ./

# 构建
RUN pnpm build

# 生产镜像
FROM node:22-bookworm-slim

WORKDIR /app

# 安装运行时依赖
RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# 复制构建产物
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./

# 创建非root用户
RUN useradd -m openclaw
USER openclaw

# 数据目录
VOLUME ["/data"]
ENV OPENCLAW_CONFIG_PATH=/data/config.json
ENV OPENCLAW_STORAGE_PATH=/data

# 端口
EXPOSE 18789 18790

# 启动命令
CMD ["node", "dist/index.js", "gateway", "--allow-unconfigured"]
```

#### 9.1.2 docker-compose.yml

```yaml
version: "3.8"

services:
  openclaw:
    build: .
    ports:
      - "18789:18789"
      - "18790:18790"
    volumes:
      - openclaw-data:/data
    environment:
      - OPENCLAW_GATEWAY_TOKEN=${OPENCLAW_GATEWAY_TOKEN}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:18790/health"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  openclaw-data:
```

### 9.2 Fly.io部署

```toml
# fly.toml
app = "openclaw"
primary_region = "iad"

[build]
  dockerfile = "Dockerfile"

[env]
  OPENCLAW_CONFIG_PATH = "/data/config.json"
  OPENCLAW_STORAGE_PATH = "/data"

[http_service]
  internal_port = 18790
  force_https = true
  auto_stop_machines = false
  auto_start_machines = true

[[services]]
  protocol = "tcp"
  internal_port = 18789

  [[services.ports]]
    port = 18789

[mounts]
  source = "openclaw_data"
  destination = "/data"

[[vm]]
  cpu_kind = "shared"
  cpus = 2
  memory_mb = 2048
```

### 9.3 Systemd服务

```ini
# /etc/systemd/system/openclaw.service
[Unit]
Description=OpenClaw Gateway
After=network.target

[Service]
Type=simple
User=openclaw
Group=openclaw
WorkingDirectory=/opt/openclaw
ExecStart=/usr/bin/node dist/index.js gateway
Restart=always
RestartSec=5

Environment=NODE_ENV=production
Environment=OPENCLAW_CONFIG_PATH=/etc/openclaw/config.json
Environment=OPENCLAW_STORAGE_PATH=/var/lib/openclaw

[Install]
WantedBy=multi-user.target
```

---

## 10. 测试设计

### 10.1 测试策略

| 测试类型 | 工具 | 覆盖目标 |
|----------|------|----------|
| 单元测试 | Vitest | 核心逻辑、工具函数 |
| 集成测试 | Vitest | 模块间交互 |
| E2E测试 | Playwright | 用户流程 |
| API测试 | Vitest | RPC方法 |

### 10.2 单元测试示例

```typescript
// src/routing/resolver.test.ts

import { describe, it, expect } from "vitest";
import { RouteResolver } from "./resolver";

describe("RouteResolver", () => {
  const config = createTestConfig();
  const resolver = new RouteResolver(config);

  describe("buildSessionKey", () => {
    it("should build per-sender session key", () => {
      const key = resolver.resolve({
        channel: "whatsapp",
        chatType: "dm",
        peerId: "+8613800138000",
        senderId: "+8613800138000",
        config,
      }).sessionKey;

      expect(key).toBe("whatsapp:dm:+8613800138000");
    });

    it("should build global session key when scope is global", () => {
      const globalConfig = { ...config, session: { scope: "global" } };
      const globalResolver = new RouteResolver(globalConfig);

      const key = globalResolver.resolve({
        channel: "whatsapp",
        chatType: "dm",
        peerId: "+8613800138000",
        senderId: "+8613800138000",
        config: globalConfig,
      }).sessionKey;

      expect(key).toBe("whatsapp:dm:global");
    });
  });

  describe("checkAccess", () => {
    it("should allow user in allowlist", () => {
      const result = resolver.resolve({
        channel: "whatsapp",
        chatType: "dm",
        peerId: "+8613800138000",
        senderId: "+8613800138000",
        config,
      });

      expect(result.allowed).toBe(true);
    });

    it("should deny user not in allowlist", () => {
      const result = resolver.resolve({
        channel: "whatsapp",
        chatType: "dm",
        peerId: "+8619999999999",
        senderId: "+8619999999999",
        config,
      });

      expect(result.allowed).toBe(false);
    });
  });
});
```

### 10.3 E2E测试示例

```typescript
// tests/e2e/chat.e2e.test.ts

import { test, expect } from "@playwright/test";

test.describe("Chat Flow", () => {
  test("should send and receive message", async ({ page }) => {
    // 1. 打开控制面板
    await page.goto("http://localhost:18790");

    // 2. 等待连接
    await expect(page.locator(".connection-status")).toHaveText("Connected");

    // 3. 导航到聊天页面
    await page.click('text="Chat"');

    // 4. 发送消息
    await page.fill(".chat-input", "Hello, world!");
    await page.click(".chat-send-btn");

    // 5. 等待响应
    await expect(page.locator(".chat-message.assistant")).toBeVisible({
      timeout: 30000,
    });

    // 6. 验证响应存在
    const response = await page.textContent(".chat-message.assistant");
    expect(response).toBeTruthy();
  });
});
```

---

## 附录

### A. 环境变量参考

| 变量名 | 描述 | 默认值 |
|--------|------|--------|
| `OPENCLAW_CONFIG_PATH` | 配置文件路径 | `~/.openclaw/config.json` |
| `OPENCLAW_STORAGE_PATH` | 存储目录 | `~/.openclaw` |
| `OPENCLAW_GATEWAY_TOKEN` | Gateway认证Token | - |
| `OPENCLAW_GATEWAY_PASSWORD` | Gateway认证密码 | - |
| `ANTHROPIC_API_KEY` | Anthropic API密钥 | - |
| `OPENAI_API_KEY` | OpenAI API密钥 | - |
| `GOOGLE_AI_API_KEY` | Google AI API密钥 | - |

### B. 错误码参考

| 错误码 | 名称 | 描述 |
|--------|------|------|
| -32700 | PARSE_ERROR | JSON解析错误 |
| -32600 | INVALID_REQUEST | 无效请求 |
| -32601 | METHOD_NOT_FOUND | 方法不存在 |
| -32602 | INVALID_PARAMS | 参数无效 |
| -32603 | INTERNAL_ERROR | 内部错误 |
| -32000 | UNAVAILABLE | 服务不可用 |

### C. 依赖版本锁定

```json
{
  "dependencies": {
    "@whiskeysockets/baileys": "7.0.0-rc.9",
    "grammy": "1.39.3",
    "@slack/bolt": "4.6.0",
    "express": "5.2.1",
    "ws": "8.19.0",
    "zod": "4.3.6",
    "lit": "3.3.2",
    "commander": "14.0.3",
    "typescript": "5.9.3"
  }
}
```

---

*文档结束*
